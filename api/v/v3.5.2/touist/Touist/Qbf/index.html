<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Qbf (touist.Touist.Qbf)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta name="generator" content="doc-ock-html v1.0.0-1-g1fc9bf0"/></head><body><nav id="top"><a href="../index.html">Up</a> &mdash; <span class="package">package <a href="../../index.html">touist</a></span></nav><header><h1><span class="keyword">Module</span> <span class="module-path">Touist.Qbf</span></h1></header><p>Transform an evaluated AST into prenex form, CNF and QDIMACS.</p><p>The order of calls is <a href="index.html#val-prenex">prenex</a> -&gt; <a href="index.html#val-cnf">cnf</a> -&gt; <a href="index.html#val-print_qdimacs">print_qdimacs</a></p><h3>Prenex and CNF</h3><p>From an evaluated AST, you want to
</p><ul><li>(1) get the Prenex Normal (PNF) Form using <a href="index.html#val-prenex">prenex</a></li><li>(2) on the PNF, get the Prenex-CNF using <a href="index.html#val-cnf">cnf</a></li></ul><div class="spec val" id="val-prenex"><a href="#val-prenex" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>prenex : ?&#8288;debug:bool <span class="keyword">&#8209;&gt;</span> <a href="../Types/index.html#module-AstSet">Types.AstSet</a>.elt <span class="keyword">&#8209;&gt;</span> <a href="../Types/Ast/index.html#type-t">Types.Ast.t</a></code></div><div class="doc"><p><code class="code">prenex ast</code> takes an evaluated AST and applies the transformation rules
in order to transform an evaluated AST into Prenex Normal Form (PNF).</p><p><b>IMPORTANT</b> Because we do not know any to transform 'xor' and '&lt;=&gt;',
these two connectors will be re-written using the other connectors.</p><ul class="at-tag"><li><span class="at-tag see">See</span> <a href="https://fr.wikipedia.org/wiki/Forme_prénexe">https://fr.wikipedia.org/wiki/Forme_prénexe</a>Transformation
rules on Wikipedia (FR)</li></ul></div></div><div class="spec val" id="val-cnf"><a href="#val-cnf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>cnf : ?&#8288;debug_cnf:bool <span class="keyword">&#8209;&gt;</span> <a href="../Types/Ast/index.html#type-t">Types.Ast.t</a> <span class="keyword">&#8209;&gt;</span> <a href="../Types/index.html#module-AstSet">Types.AstSet</a>.elt</code></div><div class="doc"><p><code class="code">cnf ast</code> calls <a href="../Cnf/index.html#val-ast_to_cnf">Cnf.ast_to_cnf</a> on the inner formula
(with no quantifiers) and existentially quantifies any Tseitlin
variable in an innermost way.</p><p><code class="code">ast</code> must be in Prenex Normal Form.</p></div></div><h3>CNF to clauses</h3><div class="spec type" id="type-quantlist"><a href="#type-quantlist" class="anchor"></a><div class="def type"><code><span class="keyword">type </span>'a quantlist</code><code></code><code><span class="keyword"> = </span></code><table class="variant"><tr id="type-quantlist.A" class="anchored"><td class="def constructor"><a href="#type-quantlist.A" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">A</span><span class="keyword"> of </span><span class="type-var">'a</span> list</code></td></tr><tr id="type-quantlist.E" class="anchored"><td class="def constructor"><a href="#type-quantlist.E" class="anchor"></a><code><span class="keyword">| </span></code><code><span class="constructor">E</span><span class="keyword"> of </span><span class="type-var">'a</span> list</code></td></tr></table><code></code></div><div class="doc"><p><code class="code">A</code> means 'forall', <code class="code">E</code> means 'exists'</p></div></div><div class="spec val" id="val-qbfclauses_of_cnf"><a href="#val-qbfclauses_of_cnf" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>qbfclauses_of_cnf : <a href="../Types/Ast/index.html#type-t">Types.Ast.t</a> <span class="keyword">&#8209;&gt;</span> int <a href="index.html#type-quantlist">quantlist</a> list<span class="keyword"> * </span>int list list<span class="keyword"> * </span>(int, string) Hashtbl.t</code></div><div class="doc"><p><code class="code">qbfclauses_of_cnf</code> translates an AST (which is in CNF) to the tuple
<code class="code">(quants, int_clauses, int_table)</code>:
</p><ul><li>1) <code class="code">quants</code> is a list of quantlist which reprensents the grouped
quantifiers in the Prenex Normal Form.</li><li>2) <code class="code">int_clauses</code> a list of lists of integers which represents the
CNF formula embedded in the Prenex Normal Form.</li><li>3) <code class="code">int_table</code> is the mapping table from litteral integers to names.</li></ul></div></div><div class="spec val" id="val-print_qdimacs"><a href="#val-print_qdimacs" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>print_qdimacs : ?&#8288;line_begin:string <span class="keyword">&#8209;&gt;</span> ?&#8288;debug_dimacs:bool <span class="keyword">&#8209;&gt;</span> (int <a href="index.html#type-quantlist">quantlist</a> list<span class="keyword"> * </span>int list list<span class="keyword"> * </span>(int, string) Hashtbl.t) <span class="keyword">&#8209;&gt;</span> ?&#8288;out_table:Pervasives.out_channel <span class="keyword">&#8209;&gt;</span> Pervasives.out_channel <span class="keyword">&#8209;&gt;</span> unit</code></div><div class="doc"><p><code class="code">print_qdimacs (quants, int_clauses, int_table) out</code> takes the
result of <a href="index.html#val-qbfclauses_of_cnf">qbfclauses_of_cnf</a> and prints the following:
</p><ul><li>1) If <code class="code">~out_table</code> is given, print the mapping table from litterals
integers to names. If <code class="code">out</code> and <code class="code">out_table</code> are the same, then the
mapping table will be printed in DIMACS comments
(e.g., 'c p(a,b) 5').</li><li>2) the DIMACS standard header line ('p cnf 3 2')</li><li>3) the quantifiers lines grouped (one quantifier per line, beginning with
'e' or 'a' and ending by 0)</li><li>4) the clauses (one conjunction per line, one line is a disjunction,
minus means 'not').</li></ul><ul class="at-tag"><li><span class="at-tag see">See</span> <a href="http://www.qbflib.org/qdimacs.html">http://www.qbflib.org/qdimacs.html</a>QDIMACS standard</li></ul></div></div><h3>Utility functions</h3><div class="spec val" id="val-is_unquant"><a href="#val-is_unquant" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_unquant : <a href="../Types/index.html#module-AstSet">Types.AstSet</a>.elt <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"><p><code class="code">is_unquant</code> checks that the given formula does not contain any quantors.</p></div></div><div class="spec val" id="val-is_prenex"><a href="#val-is_prenex" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>is_prenex : <a href="../Types/index.html#module-AstSet">Types.AstSet</a>.elt <span class="keyword">&#8209;&gt;</span> bool</code></div><div class="doc"></div></div><div class="spec val" id="val-regroup_quantors"><a href="#val-regroup_quantors" class="anchor"></a><div class="def val"><code><span class="keyword">val </span>regroup_quantors : <a href="../Types/Ast/index.html#type-t">Types.Ast.t</a> <span class="keyword">&#8209;&gt;</span> string <a href="index.html#type-quantlist">quantlist</a> list <span class="keyword">&#8209;&gt;</span> string <a href="index.html#type-quantlist">quantlist</a> list<span class="keyword"> * </span><a href="../Types/Ast/index.html#type-t">Types.Ast.t</a></code></div><div class="doc"><p><code class="code">regroup_quantors</code> gathers all succeeding Forall and Exists to a list
of list such that each sublist only contains one type of quantor.
Example: </p><pre><code class="code">      Forall (&quot;a&quot;,Forall (&quot;b&quot;,Exists (&quot;c&quot;, Forall (&quot;d&quot;,_)))</code></pre><p> becomes </p><pre><code class="code">      [A of [&quot;a&quot;;&quot;b&quot;]; E of [&quot;c&quot;]; A of [&quot;d&quot;]]</code></pre></div></div></body></html>