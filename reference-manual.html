<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
  <meta name="generator" content="Madoko, version 1.0.3" />
  <meta name="viewport" content="initial-scale=1.0" />
  <meta name="author" content="Maël Valais" />
  <title>Touist reference manual</title>
  <style type="text/css"  class="link">
  /*# sourceURL=madoko.css */
  
  .madoko .toc>.tocblock .tocblock .tocblock {
    margin-left: 2.25em;
  }
  .madoko .toc>.tocblock .tocblock {
    margin-left: 1.5em;
  }
  .madoko .toc-contents>.tocblock>.tocitem {
    font-weight: bold;
  }
  .madoko .toc {
    margin-top: 1em;
  }
  .madoko p.para-continue {
    margin-bottom: 0pt;
  }
  .madoko .para-block+p {
    margin-top: 0pt;
  }
  .madoko ul.para-block, .madoko ol.para-block {
    margin-top: 0pt;
    margin-bottom: 0pt;
  }
  .madoko ul.para-end, .madoko ol.para-end {
    margin-bottom: 1em;
  }
  .madoko dl {
    margin-left: 0em;
  }
  .madoko blockquote {
    font-style: italic;
  }
  .madoko a.localref {
    text-decoration: none;
  }
  .madoko a.localref:hover {
    text-decoration: underline;
  }
  .madoko .footnotes {
    font-size: smaller;
    margin-top: 2em;
  }
  .madoko .footnotes hr {
    width: 50%;
    text-align: left;
  }
  .madoko .footnote { 
    margin-left: 1em;
  }
  .madoko .footnote-before {
    margin-left: -1em;
    width: 1em;
    display: inline-block;
  }
  .madoko .align-center, .madoko .align-center>p {
    text-align: center !important;
  }
  .madoko .align-center pre {
    text-align: left;
  }
  .madoko .align-center>* {
    margin-left: auto !important;
    margin-right: auto !important;
  }
  .madoko .align-left, .madoko .align-left>p {
    text-align: left !important;
  }
  .madoko .align-left>* {
    margin-left: 0pt !important;
    margin-right: auto !important;
  }
  .madoko .align-right, .madoko .align-right>p {
    text-align: right !important;
  }
  .madoko .align-right>* {
    margin-left: auto !important;
    margin-right: 0pt !important;
  }
  .madoko .align-center>table,
  .madoko .align-left>table,
  .madoko .align-right>table {
    text-align: left !important;
  }
  .madoko .equation-before {
    float: right;
  }
  .madoko .bibitem {
    font-size: smaller;
  }
  .madoko .bibsearch {
    font-size: x-small;
    text-decoration:none;
    color: black;
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  .madoko .block, .madoko .figure, .madoko .bibitem, .madoko .equation, .madoko div.math {
    margin-top: 1ex;
    margin-bottom: 1ex;
  }
  .madoko .figure {
    padding: 0.5em;
    margin-left: 0pt;
    margin-right: 0pt;
  }
  .madoko .hidden {
    display: none;
  }
  .madoko .invisible {
    visibility: hidden;
  }
  .madoko.preview .invisible {
    visibility: visible;
    opacity: 0.5;
  }
  .madoko code.code, .madoko span.code {
    white-space: pre-wrap;
  }
  .madoko hr, hr.madoko {
    border: none;
    border-bottom: black solid 1px;
    margin-bottom: 0.5ex;
  }
  .madoko .framed>*:first-child {
    margin-top: 0pt;
  }
  .madoko .framed>*:last-child {
    margin-bottom: 0pt;
  }
  .madoko ul.list-style-type-dash {
      list-style-type: none !important;
  }
  .madoko ul.list-style-type-dash > li:before {
      content: "\2013"; 
      position: absolute;
      margin-left: -1em; 
  }
  .madoko table.madoko {
    border-collapse: collapse;
  }
  .madoko td, .madoko th {
    padding: 0ex 0.5ex;
    margin: 0pt;
    vertical-align: top;
  }
  .madoko .cell-border-left {
    border-left: 1px solid black;
  }
  .madoko .cell-border-right {
    border-right: 1px solid black;
  }
  .madoko thead>tr:first-child>.cell-line,
  .madoko tbody:first-child>tr:first-child>.cell-line {
    border-top: 1px solid black;
    border-bottom: none;
  }
  .madoko .cell-line, .madoko .cell-double-line {
    border-bottom: 1px solid black;
    border-top: none;
  }
  .madoko .cell-double-line {
    border-top: 1px solid black;
    padding-top: 1.5px !important;
  }
  .madoko .input-mathpre .MathJax_Display {
    text-align: left !important;
  }
  .madoko div.input-mathpre {
    text-align: left;
    margin-top: 1.5ex;
    margin-bottom: 1ex;
  }
  .madoko .math-rendering {
    color: gray;
  }
  .madoko .mathdisplay {
    text-align: center;
  }
  .madoko .pretty table {
    border-collapse: collapse;
  }
  .madoko .pretty td {
    padding: 0em;
  }
  .madoko .pretty td.empty {
    min-width: 1.5ex;
  }
  .madoko .pretty td.expander {
    width: 100em;
  }
  body.madoko, .madoko .serif {
    font-family: Cambria,"Times New Roman","Liberation Serif","Times",serif;
  }
  .madoko .sans-serif {
    font-family: "Calibri", "Optima", sans-serif;
  }
  .madoko .symbol {
    font-family: "Segoe UI Symbol", Symbola, serif;
  }
  body.madoko {  
    -webkit-text-size-adjust: 100%;       
    text-rendering: optimizeLegibility;
  }
  body.madoko {
    max-width: 88ex; 
    margin: 1em auto;
    padding: 0em 2em;  
  }
  body.preview.madoko {
    padding: 0em 1em;
  }
  .madoko p {
    text-align: justify;
  }
  .madoko h1, .madoko h2, .madoko h3, .madoko h4 { 
    margin-top: 1.22em; 
    margin-bottom: 1ex;
  }
  .madoko h1+p, .madoko h2+p, .madoko h3+p, .madoko h4+p, .madoko h5+p  { 
    margin-top: 1ex;    
  }
  .madoko h5, .madoko h6 { 
    margin-top: 1ex;
    font-size: 1em;
  }
  .madoko h5 { 
    margin-bottom: 0.5ex;
  }
  .madoko h5 + p {
    margin-top: 0.5ex;
  }
  .madoko h6 { 
    margin-bottom: 0pt;
  }
  .madoko h6 + p {
    margin-top: 0pt;
  }
  .madoko pre, .madoko code, .madoko kbd, .madoko samp, .madoko tt, 
  .madoko .monospace, .madoko .token-indent, .madoko .reveal pre, .madoko .reveal code, .madoko .email {
    font-family: Consolas,"Andale Mono WT","Andale Mono",Lucida Console,Monaco,monospace,monospace;
    font-size: 0.85em;
  }
  .madoko pre code, .madoko .token-indent {
    font-size: 0.95em;
  }
  .madoko pre code {
    font-family: inherit !important;
  }
  .madoko ol.linenums li {
    background-color: white;
    list-style-type: decimal;
  }
  .madoko .remote {
    background-color: #F0FFF0;
  }
  .madoko .remote + * {
    margin-top: 0pt;
  }
  @media print {
    body.madoko {
      font-size: 10pt;
    }
    @page {
      margin: 1in 1.5in;
    }
  }
  @media only screen and (max-device-width:1024px) {
    body.madoko {
      padding: 0em 0.5em;    
    }
    .madoko li {
      text-align: left;
    }
  }
  
    </style>
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {inlineMath: [['$','$']]},
       TeX: { 
         Macros: { mathid: ['\\mathit{#1\\hspace{0.1ex}}',1],
                   mathkw: ['\\mathsf{#1}',1],
                   mdmathindent: ['\\hspace{#1ex}',1],
                   mathpre: ['#1',1],
                 },
  
       }
    });
    MathJax.Hub.Register.StartupHook('TeX AMSmath Ready',function () { 
      MathJax.InputJax.TeX.Definitions.environment['mdmathpre'] = ['AMSarray',null,null,null,'l','0em','0em'];
    });
  </script>
  <script type="text/javascript" class="preview"
    src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
  
  </head>
<body class="madoko">

<div class="body madoko" style="line-adjust:0">
<div class="titleblock align-center para-block" data-line="12" style="text-align:center;line-adjust:0">
<div class="titleheader align-center" data-line="12" style="text-align:center;line-adjust:0">
<div class="title para-block" data-line="12" style="font-size:xx-large;font-weight:bold;margin-bottom:0.5ex;line-adjust:0"><span data-line="12"></span>Touist reference manual</div>
<div class="titlenote para-block" data-line="15" style="line-adjust:0"><span data-line="15"></span>2017-03-30 (touist v3.0.1-5-g3b3deed)</div></div>
<div class="authors align-center" data-line="20" style="text-align:center;width:80%;line-adjust:0"><table class="authorrow columns block" data-line="20" style="margin-top:2ex;width:100%;line-adjust:0">
<tbody><tr><td class="author column" data-line="20" style="text-align:center;line-adjust:0">
<div class="authorname" data-line="20" style="font-size:large;line-adjust:0"><span data-line="20"></span>Olivier Gasquet</div></td><td class="author column" data-line="25" style="text-align:center;line-adjust:0">
<div class="authorname" data-line="25" style="font-size:large;line-adjust:0"><span data-line="25"></span>Frédéric Maris</div></td><td class="author column" data-line="30" style="text-align:center;line-adjust:0">
<div class="authorname" data-line="30" style="font-size:large;line-adjust:0"><span data-line="30"></span>Maël Valais</div></td></tr></tbody></table></div></div><span data-line="14"></span>
<nav class="toc toc-contents"><h2 id="sec-contents" class="clearnum h1 heading-contents" data-heading-depth="1" style="display:block">Contents</h2>
<div class="tocblock tocblock1">
<div class="tocitem tocitem1" data-toc-target="sec-introduction" data-toc-depth="1" data-toc-line="[1]{.heading-label}.&#8194;Introduction" style="toctarget:sec-introduction"><a href="#sec-introduction" class="localref"><span class="heading-label">1</span>.&#8194;Introduction</a></div>
<div class="tocblock tocblock2">
<div class="tocitem tocitem2" data-toc-target="sec-simple-inference-checking" data-toc-depth="2" data-toc-line="[1.1]{.heading-label}.&#8194;Simple inference checking" style="toctarget:sec-simple-inference-checking"><a href="#sec-simple-inference-checking" class="localref"><span class="heading-label">1.1</span>.&#8194;Simple inference checking</a></div></div>
<div class="tocitem tocitem1" data-toc-target="sec-language-reference" data-toc-depth="1" data-toc-line="[2]{.heading-label}.&#8194;Language reference" style="toctarget:sec-language-reference"><a href="#sec-language-reference" class="localref"><span class="heading-label">2</span>.&#8194;Language reference</a></div>
<div class="tocblock tocblock2">
<div class="tocitem tocitem2" data-toc-target="sec-structure-of-a-touist-file" data-toc-depth="2" data-toc-line="[2.1]{.heading-label}.&#8194;Structure of a touist file" style="toctarget:sec-structure-of-a-touist-file"><a href="#sec-structure-of-a-touist-file" class="localref"><span class="heading-label">2.1</span>.&#8194;Structure of a touist file</a></div>
<div class="tocitem tocitem2" data-toc-target="affect" data-toc-depth="2" data-toc-line="[2.2]{.heading-label}.&#8194;Affectations" style="toctarget:affect"><a href="#affect" class="localref"><span class="heading-label">2.2</span>.&#8194;Affectations</a></div>
<div class="tocitem tocitem2" data-toc-target="sec-variables" data-toc-depth="2" data-toc-line="[2.3]{.heading-label}.&#8194;Variables" style="toctarget:sec-variables"><a href="#sec-variables" class="localref"><span class="heading-label">2.3</span>.&#8194;Variables</a></div>
<div class="tocitem tocitem2" data-toc-target="sec-propositions" data-toc-depth="2" data-toc-line="[2.4]{.heading-label}.&#8194;Propositions" style="toctarget:sec-propositions"><a href="#sec-propositions" class="localref"><span class="heading-label">2.4</span>.&#8194;Propositions</a></div>
<div class="tocblock tocblock3">
<div class="tocitem tocitem3" data-toc-target="tuple-prop-set" data-toc-depth="3" data-toc-line="[2.4.1]{.heading-label}.&#8194;Tuple proposition containing a set" style="toctarget:tuple-prop-set"><a href="#tuple-prop-set" class="localref"><span class="heading-label">2.4.1</span>.&#8194;Tuple proposition containing a set</a></div></div>
<div class="tocitem tocitem2" data-toc-target="sec-numeric-expression" data-toc-depth="2" data-toc-line="[2.5]{.heading-label}.&#8194;Numeric expression" style="toctarget:sec-numeric-expression"><a href="#sec-numeric-expression" class="localref"><span class="heading-label">2.5</span>.&#8194;Numeric expression</a></div>
<div class="tocblock tocblock3">
<div class="tocitem tocitem3" data-toc-target="sec-integers" data-toc-depth="3" data-toc-line="[2.5.1]{.heading-label}.&#8194;Integers" style="toctarget:sec-integers"><a href="#sec-integers" class="localref"><span class="heading-label">2.5.1</span>.&#8194;Integers</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-floats" data-toc-depth="3" data-toc-line="[2.5.2]{.heading-label}.&#8194;Floats" style="toctarget:sec-floats"><a href="#sec-floats" class="localref"><span class="heading-label">2.5.2</span>.&#8194;Floats</a></div></div>
<div class="tocitem tocitem2" data-toc-target="sec-booleans" data-toc-depth="2" data-toc-line="[2.6]{.heading-label}.&#8194;Booleans" style="toctarget:sec-booleans"><a href="#sec-booleans" class="localref"><span class="heading-label">2.6</span>.&#8194;Booleans</a></div>
<div class="tocitem tocitem2" data-toc-target="sec-sets" data-toc-depth="2" data-toc-line="[2.7]{.heading-label}.&#8194;Sets" style="toctarget:sec-sets"><a href="#sec-sets" class="localref"><span class="heading-label">2.7</span>.&#8194;Sets</a></div>
<div class="tocblock tocblock3">
<div class="tocitem tocitem3" data-toc-target="sec-sets-defined-by-enumeration" data-toc-depth="3" data-toc-line="[2.7.1]{.heading-label}.&#8194;Sets defined by enumeration" style="toctarget:sec-sets-defined-by-enumeration"><a href="#sec-sets-defined-by-enumeration" class="localref"><span class="heading-label">2.7.1</span>.&#8194;Sets defined by enumeration</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-sets-defined-by-a-range" data-toc-depth="3" data-toc-line="[2.7.2]{.heading-label}.&#8194;Sets defined by a range" style="toctarget:sec-sets-defined-by-a-range"><a href="#sec-sets-defined-by-a-range" class="localref"><span class="heading-label">2.7.2</span>.&#8194;Sets defined by a range</a></div>
<div class="tocitem tocitem3" data-toc-target="set-builder" data-toc-depth="3" data-toc-line="[2.7.3]{.heading-label}.&#8194;Set-builder notation" style="toctarget:set-builder"><a href="#set-builder" class="localref"><span class="heading-label">2.7.3</span>.&#8194;Set-builder notation</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-operators-using-sets" data-toc-depth="3" data-toc-line="[2.7.4]{.heading-label}.&#8194;Operators using sets" style="toctarget:sec-operators-using-sets"><a href="#sec-operators-using-sets" class="localref"><span class="heading-label">2.7.4</span>.&#8194;Operators using sets</a></div></div>
<div class="tocitem tocitem2" data-toc-target="sec-formulas" data-toc-depth="2" data-toc-line="[2.8]{.heading-label}.&#8194;Formulas" style="toctarget:sec-formulas"><a href="#sec-formulas" class="localref"><span class="heading-label">2.8</span>.&#8194;Formulas</a></div>
<div class="tocblock tocblock3">
<div class="tocitem tocitem3" data-toc-target="sec-connectors" data-toc-depth="3" data-toc-line="[2.8.1]{.heading-label}.&#8194;Connectors" style="toctarget:sec-connectors"><a href="#sec-connectors" class="localref"><span class="heading-label">2.8.1</span>.&#8194;Connectors</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-generalized-connectors" data-toc-depth="3" data-toc-line="[2.8.2]{.heading-label}.&#8194;Generalized connectors" style="toctarget:sec-generalized-connectors"><a href="#sec-generalized-connectors" class="localref"><span class="heading-label">2.8.2</span>.&#8194;Generalized connectors</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-propositional-logic-formulas" data-toc-depth="3" data-toc-line="[2.8.3]{.heading-label}.&#8194;Propositional logic formulas" style="toctarget:sec-propositional-logic-formulas"><a href="#sec-propositional-logic-formulas" class="localref"><span class="heading-label">2.8.3</span>.&#8194;Propositional logic formulas</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-smt-formulas" data-toc-depth="3" data-toc-line="[2.8.4]{.heading-label}.&#8194;SMT formulas" style="toctarget:sec-smt-formulas"><a href="#sec-smt-formulas" class="localref"><span class="heading-label">2.8.4</span>.&#8194;SMT formulas</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-local-variables" data-toc-depth="3" data-toc-line="[2.8.5]{.heading-label}.&#8194;Local variables" style="toctarget:sec-local-variables"><a href="#sec-local-variables" class="localref"><span class="heading-label">2.8.5</span>.&#8194;Local variables</a></div></div>
<div class="tocitem tocitem2" data-toc-target="sec-formal-grammar" data-toc-depth="2" data-toc-line="[2.9]{.heading-label}.&#8194;Formal grammar" style="toctarget:sec-formal-grammar"><a href="#sec-formal-grammar" class="localref"><span class="heading-label">2.9</span>.&#8194;Formal grammar</a></div></div>
<div class="tocitem tocitem1" data-toc-target="sec-command-line-tool-touist" data-toc-depth="1" data-toc-line="[3]{.heading-label}.&#8194;Command-line tool (`touist`)" style="toctarget:sec-command-line-tool-touist"><a href="#sec-command-line-tool-touist" class="localref"><span class="heading-label">3</span>.&#8194;Command-line tool (<code class="code code1">touist</code>)</a></div>
<div class="tocblock tocblock2">
<div class="tocitem tocitem2" data-toc-target="sec-installation" data-toc-depth="2" data-toc-line="[3.1]{.heading-label}.&#8194;Installation" style="toctarget:sec-installation"><a href="#sec-installation" class="localref"><span class="heading-label">3.1</span>.&#8194;Installation</a></div>
<div class="tocitem tocitem2" data-toc-target="cli" data-toc-depth="2" data-toc-line="[3.2]{.heading-label}.&#8194;Usage" style="toctarget:cli"><a href="#cli" class="localref"><span class="heading-label">3.2</span>.&#8194;Usage</a></div>
<div class="tocblock tocblock3">
<div class="tocitem tocitem3" data-toc-target="sec-usage-for-propositional-logic-sat-mode" data-toc-depth="3" data-toc-line="[3.2.1]{.heading-label}.&#8194;Usage for propositional logic (SAT mode)" style="toctarget:sec-usage-for-propositional-logic-sat-mode"><a href="#sec-usage-for-propositional-logic-sat-mode" class="localref"><span class="heading-label">3.2.1</span>.&#8194;Usage for propositional logic (SAT mode)</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-other-options" data-toc-depth="3" data-toc-line="[3.2.2]{.heading-label}.&#8194;Other options" style="toctarget:sec-other-options"><a href="#sec-other-options" class="localref"><span class="heading-label">3.2.2</span>.&#8194;Other options</a></div>
<div class="tocitem tocitem3" data-toc-target="sec-usage-for-satisfiability-modulo-theory-smt-mode" data-toc-depth="3" data-toc-line="[3.2.3]{.heading-label}.&#8194;Usage for Satisfiability Modulo Theory (SMT mode)" style="toctarget:sec-usage-for-satisfiability-modulo-theory-smt-mode"><a href="#sec-usage-for-satisfiability-modulo-theory-smt-mode" class="localref"><span class="heading-label">3.2.3</span>.&#8194;Usage for Satisfiability Modulo Theory (SMT mode)</a></div></div></div>
<div class="tocitem tocitem1" data-toc-target="sec-references" data-toc-depth="1" data-toc-line="References" style="toctarget:sec-references"><a href="#sec-references" class="localref">References</a></div></div></nav><!-- Maël: for now, you can ignore the error "undefined key: version" -->

<h2 id="sec-introduction" class="h1" data-line="16" data-heading-depth="1" style="display:block"><span data-line="16"></span><span class="heading-before"><span class="heading-label">1</span>.&#8194;</span><span data-line="16"></span>Introduction</h2>
<p class="p noindent" data-line="18"><span data-line="18"></span>Touist is a language that allows to express propositional logic
<span data-line="19"></span><span class="citations" style="target-element:bibitem">[<a href="#ben_slimane_iaf_2015" title="La logique facile avec TouIST (formalisez et résolvez facilement des problèmes du monde réel)
Ben Slimane, Comte, Gasquet, Heba, Lezaud, Maris, and Valais, 2015a" class="bibref localref" style="target-element:bibitem"><span class="cite-number">1</span></a>, <a href="#slimanecghlmv15" title="Twist your logic with TouIST
Ben Slimane, Comte, Gasquet, Heba, Lezaud, Maris, and Valais, 2015b" class="bibref localref" style="target-element:bibitem"><span class="cite-number">2</span></a>]</span><span data-line="19"></span>. You are provided with two programs: a
graphical interface, refered as <span data-line="20"></span><code class="code code1">touist.jar</code><span data-line="20"></span> (as it is written in Java) and
<span data-line="21"></span><code class="code code1">touist</code><span data-line="21"></span>, the command-line compiler and solver (written in Ocaml).
</p>
<p class="p indent" data-line="23"><span data-line="23"></span>The touist language aims at making the writing of propositional logic as
approchable as possible. Propositions and connectors syntaxes are close to what
would be written on paper. Propositions are words that can contain numbers, the
character <span data-line="26"></span>&#8220;<code class="code code1">_</code>&#8221;<span data-line="26"></span>. Here are some examples of formulas:
</p>
<div class="center align-center" data-line="28" style="text-align:center"><table class="madoko block" data-line="29">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="29" data-row="0" data-col="1" style="text-align:center"></th><th class="thead tr-even col cell-line col-even col-last" data-line="29" data-row="0" data-col="2" style="text-align:center"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="30" data-row="1" data-col="1" style="font-weight:bold;text-align:center"><span data-line="30"></span> Propositional logic   </th><th class="col thead tr-odd tr-last tr-first col-even col-last" data-line="30" data-row="1" data-col="2" style="font-weight:bold;text-align:center"><span data-line="30"></span> <span data-line="30"></span><code class="code code1">touist</code><span data-line="30"></span> language </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1" style="text-align:center"></td><td class="tbody tr-even col cell-line col-even col-last" data-row="0" data-col="2" style="text-align:center"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="32" data-row="1" data-col="1" style="text-align:center"><span data-line="32"></span> <span data-line="32"></span><span class="math-inline">$\neg p$</span><span data-line="32"></span>              </td><td class="tbody tr-odd tr-first col col-even col-last" data-line="32" data-row="1" data-col="2" style="text-align:center"><span data-line="32"></span> <span data-line="32"></span><code class="code code2 language-touist lang-touist touist colorized">not p</code><span data-line="32"></span>         </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="33" data-row="2" data-col="1" style="text-align:center"><span data-line="33"></span> <span data-line="33"></span><span class="math-inline">$p \wedge q$</span><span data-line="33"></span>          </td><td class="tbody tr-even col col-even col-last" data-line="33" data-row="2" data-col="2" style="text-align:center"><span data-line="33"></span> <span data-line="33"></span><code class="code code2 language-touist lang-touist touist colorized">p and q</code><span data-line="33"></span>       </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="34" data-row="3" data-col="1" style="text-align:center"><span data-line="34"></span> <span data-line="34"></span><span class="math-inline">$p \vee q$</span><span data-line="34"></span>            </td><td class="tbody tr-odd col col-even col-last" data-line="34" data-row="3" data-col="2" style="text-align:center"><span data-line="34"></span> <span data-line="34"></span><code class="code code2 language-touist lang-touist touist colorized">p or q</code><span data-line="34"></span>        </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="35" data-row="4" data-col="1" style="text-align:center"><span data-line="35"></span> <span data-line="35"></span><span class="math-inline">$p \oplus q$</span><span data-line="35"></span>          </td><td class="tbody tr-even col col-even col-last" data-line="35" data-row="4" data-col="2" style="text-align:center"><span data-line="35"></span> <span data-line="35"></span><code class="code code2 language-touist lang-touist touist colorized">p xor q</code><span data-line="35"></span>       </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="36" data-row="5" data-col="1" style="text-align:center"><span data-line="36"></span> <span data-line="36"></span><span class="math-inline">$p \rightarrow q$</span><span data-line="36"></span>     </td><td class="tbody tr-odd col col-even col-last" data-line="36" data-row="5" data-col="2" style="text-align:center"><span data-line="36"></span> <span data-line="36"></span><code class="code code2 language-touist lang-touist touist colorized">p =&gt; q</code><span data-line="36"></span>        </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="37" data-row="6" data-col="1" style="text-align:center"><span data-line="37"></span> <span data-line="37"></span><span class="math-inline">$p \leftrightarrow q$</span><span data-line="37"></span> </td><td class="tbody tr-even tr-last col col-even col-last" data-line="37" data-row="6" data-col="2" style="text-align:center"><span data-line="37"></span> <span data-line="37"></span><code class="code code2 language-touist lang-touist touist colorized">p &lt;=&gt; q</code><span data-line="37"></span>       </td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="38" data-row="6" data-col="1" style="text-align:center"></td><td class="tbody tr-even col cell-line col-even col-last" data-line="38" data-row="6" data-col="2" style="text-align:center"></td></tr></tbody></table></div>
<p class="p noindent" data-line="41"><span data-line="41"></span>After typing a formula, you can ask <span data-line="41"></span><code class="code code1">touist</code><span data-line="41"></span> to find a valuation (true or
false) of each proposition so that the whole formula is true (such valuation,
also called <span data-line="43"></span><em class="em-low1">interpretation</em><span data-line="43"></span>, is called <span data-line="43"></span><em class="em-low1">model</em><span data-line="43"></span>). When a model exists, your
formula is <span data-line="44"></span><em class="em-low1">satisfiable</em><span data-line="44"></span>. For example, a model of <span data-line="44"></span><span class="math-inline">$p \vee q$</span><span data-line="44"></span> is <span data-line="44"></span><span class="math-inline">$\{p = true,q =false\}$</span><span data-line="45"></span>. To check the models of this formula using <span data-line="45"></span><code class="code code1">touist</code><span data-line="45"></span>, you can do
</p>
<div class="center align-center" data-line="47" style="text-align:center"><table class="madoko block" data-line="48">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="48" data-row="0" data-col="1"></th><th class="thead tr-even col cell-line col-even col-last" data-line="48" data-row="0" data-col="2"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="49" data-row="1" data-col="1" style="font-weight:bold"><span data-line="49"></span> Graphical Java interface            </th><th class="col thead tr-odd tr-last tr-first col-even col-last" data-line="49" data-row="1" data-col="2" style="font-weight:bold"><span data-line="49"></span> Command-line interface (see<span data-line="49"></span>&nbsp;<a href="#cli" title="3.2.&#8194;Usage" class="localref" style="target-element:h2"><span class="heading-label">3.2</span></a><span data-line="49"></span>) </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-line col-even col-last" data-row="0" data-col="2"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="51" data-row="1" data-col="1"><span data-line="51"></span> 1. Type <span data-line="51"></span><code class="code code2 language-touist lang-touist touist colorized">p and q</code><span data-line="51"></span>                 </td><td class="tbody tr-odd tr-first col col-even col-last" data-line="51" data-row="1" data-col="2"><span data-line="51"></span> 1. Create a file <span data-line="51"></span><code class="code code2 language-touist lang-touist touist colorized">p and q</code><span data-line="51"></span>        </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="52" data-row="2" data-col="1"><span data-line="52"></span> 2. Press <span data-line="52"></span>&#8220;Solve&#8221;<span data-line="52"></span>                    </td><td class="tbody tr-even col col-even col-last" data-line="52" data-row="2" data-col="2"><span data-line="52"></span> 2. Type <span data-line="52"></span><code class="code code1">./touist --solve yourfile</code><span data-line="52"></span> </td></tr>
<tr><td class="tbody tr-odd tr-last col col-odd col-first" data-line="53" data-row="3" data-col="1"><span data-line="53"></span> 3. Press <span data-line="53"></span>&#8220;Next&#8221;<span data-line="53"></span> to see other models </td><td class="tbody tr-odd tr-last col col-even col-last" data-line="53" data-row="3" data-col="2"><span data-line="53"></span> 3. The first model is displayed     </td></tr></tbody></table></div><h3 id="sec-simple-inference-checking" class="h2" data-line="57" data-heading-depth="2" style="display:block"><span data-line="57"></span><span class="heading-before"><span class="heading-label">1.1</span>.&#8194;</span><span data-line="57"></span>Simple inference checking</h3>
<p class="p noindent" data-line="59"><span data-line="59"></span>Checking the truth of a given reasoning (or <span data-line="59"></span><em class="em-low1">inference</em><span data-line="59"></span>) may be handy. From a
wikipedia example:
</p><table class="madoko block" data-line="62">
<tbody><tr><td class="tbody tr-even col cell-border-left cell-line col-odd col-first" data-row="0" data-col="1" style="text-align:right"></td><td class="tbody tr-even col cell-border-right cell-line col-even col-last" data-row="0" data-col="2" style="text-align:left"></td></tr>
<tr><td class="tbody tr-odd tr-first col cell-border-left col-odd col-first" data-line="63" data-row="1" data-col="1" style="text-align:right"><span data-line="63"></span><em class="em-star1">Premise 1:</em><span data-line="63"></span>  </td><td class="tbody tr-odd tr-first col cell-border-right col-even col-last" data-line="63" data-row="1" data-col="2" style="text-align:left"><span data-line="63"></span> If it<span data-line="63"></span>&#39;<span data-line="63"></span>s raining then it<span data-line="63"></span>&#39;<span data-line="63"></span>s cloudy </td></tr>
<tr><td class="tbody tr-even col cell-border-left col-odd col-first" data-line="64" data-row="2" data-col="1" style="text-align:right"><span data-line="64"></span><em class="em-star1">Premise 2:</em><span data-line="64"></span>  </td><td class="tbody tr-even col cell-border-right col-even col-last" data-line="64" data-row="2" data-col="2" style="text-align:left"><span data-line="64"></span> It<span data-line="64"></span>&#39;<span data-line="64"></span>s raining                     </td></tr>
<tr><td class="tbody tr-odd tr-last col cell-border-left col-odd col-first" data-line="65" data-row="3" data-col="1" style="text-align:right"><span data-line="65"></span><em class="em-star1">Conclusion:</em><span data-line="65"></span> </td><td class="tbody tr-odd tr-last col cell-border-right col-even col-last" data-line="65" data-row="3" data-col="2" style="text-align:left"><span data-line="65"></span> It<span data-line="65"></span>&#39;<span data-line="65"></span>s cloudy                      </td></tr>
<tr><td class="tbody tr-odd col cell-border-left cell-line col-odd col-first" data-line="66" data-row="3" data-col="1" style="text-align:right"></td><td class="tbody tr-odd col cell-border-right cell-line col-even col-last" data-line="66" data-row="3" data-col="2" style="text-align:left"></td></tr></tbody></table>
<p class="p noindent para-continue" data-line="68"><span data-line="68"></span>This inference can be written
</p>
<div class="math para-block" data-line="70">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="71" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\{ raining \rightarrow cloudy, raining\} \models cloudy
\]</span></div></div>
<p class="p noindent para-continued" data-line="74"><span data-line="74"></span>The <span data-line="74"></span><em class="em-low1">infer</em><span data-line="74"></span> symbol (<span data-line="74"></span><span class="math-inline">$\models$</span><span data-line="74"></span>) does not belong to the <span data-line="74"></span><code class="code code1">touist</code><span data-line="74"></span> language (we
call it <span data-line="75"></span>&#8220;meta-language&#8221;<span data-line="75"></span>). This means that we have to transform this notation to
an actual propositional formula.
</p>
<div class="theorem" data-line="78" style="display:block;margin:1ex 0pt">
<p class="p noindent" data-line="79"><span data-line="79"></span><span class="theorem-before"><strong class="strong-star2">Theorem&#160;<span class="theorem-label">1</span>.</strong> <span class="theorem-caption"></span><br>
</span><span data-line="79"></span>Let <span data-line="79"></span><span class="math-inline">$H$</span><span data-line="79"></span> be a set of formulas (called <span data-line="79"></span><em class="em-low1">hypotheses</em><span data-line="79"></span> or <span data-line="79"></span><em class="em-low1">premises</em><span data-line="79"></span>) and <span data-line="79"></span><span class="math-inline">$C$</span><span data-line="79"></span> a
formula (called <span data-line="80"></span><em class="em-low1">conclusion</em><span data-line="80"></span>). Then
</p>
<div class="center align-center" data-line="81" style="text-align:center">
<p class="p noindent" data-line="82"><span data-line="82"></span>  <span data-line="82"></span><span class="math-inline">$H \models C$</span><span data-line="82"></span> if and only if <span data-line="82"></span><span class="math-inline">$H\cup\{\neg C\}$</span><span data-line="82"></span> is unsatisfiable.</p></div></div>
<p class="p noindent para-continue" data-line="86"><span data-line="86"></span>From this theorem, we just have to check that the set of formulas
</p>
<div class="math para-block" data-line="87">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="88" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\{ raining \rightarrow cloudy, raining, \neg cloudy \}
\]</span></div></div>
<p class="p noindent para-continued" data-line="90"><span data-line="90"></span>has no model. We can translate this set to <span data-line="90"></span><code class="code code1">touist</code><span data-line="90"></span> language (comments begin
with two semi-colon <span data-line="91"></span>&#8220;<code class="code code1">;;</code>&#8221;<span data-line="91"></span>):
</p>
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="93" data-line-first="94" style="display:block"><code data-line="94">raining =&gt; cloudy       <span style="color:darkgreen">;; Premise 1</span>
raining                 <span style="color:darkgreen">;; Premise 2</span>
not cloudy              <span style="color:darkgreen">;; Conclusion</span></code></pre>
<div class="note" data-line="99" style="display:block">
<p class="p noindent" data-line="100"><span data-line="100"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="101"></span>In touist, the premises are simply formulas separated by a new line. A new line
is semantically equivalent to the <span data-line="102"></span><code class="code code1">and</code><span data-line="102"></span> connector: the previous bit of <span data-line="102"></span><code class="code code1">touist</code><span data-line="102"></span>
code could be equivalently written
</p>
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="104" data-line-first="105" style="display:block"><code data-line="105">(raining =&gt; cloudy) and raining and not cloudy  </code></pre></div><h2 id="sec-language-reference" class="h1" data-line="110" data-heading-depth="1" style="display:block"><span data-line="110"></span><span class="heading-before"><span class="heading-label">2</span>.&#8194;</span><span data-line="110"></span>Language reference</h2><h3 id="sec-structure-of-a-touist-file" class="h2" data-line="112" data-heading-depth="2" style="display:block"><span data-line="112"></span><span class="heading-before"><span class="heading-label">2.1</span>.&#8194;</span><span data-line="112"></span>Structure of a touist file</h3>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="114" data-line-first="115" style="display:block"><code data-line="115"><span style="color:purple">&lt;touist-file&gt;</span> ::= <span style="color:purple">&lt;affect&gt;</span> <span style="color:purple">&lt;touist-file&gt;</span>
                | <span style="color:purple">&lt;formula&gt;</span> <span style="color:purple">&lt;touist-file&gt;</span>
                | EOF</code></pre>
<p class="p noindent para-continued" data-line="120"><span data-line="120"></span>A touist file is a whitespace-separated list of affectations and formulas.
Affectations are global and cannot be done in nested formulas. They can be
anywhere in the file (at the beginning, at the end or interlaced with formulas).
A whitespace is a space, tab or newline.
</p>
<p class="p indent" data-line="125"><span data-line="125"></span>Comments begin with the <span data-line="125"></span>&#8220;<code class="code code2 language-touist lang-touist touist colorized"><span style="color:darkgreen">;;</span></code>&#8221;<span data-line="125"></span> sequence.
</p><h3 id="affect" class="h2" data-line="127" data-heading-depth="2" style="display:block"><span data-line="127"></span><span class="heading-before"><span class="heading-label">2.2</span>.&#8194;</span><span data-line="127"></span>Affectations</h3>
<p class="p noindent" data-line="128"><span data-line="128"></span>Affectations have the following syntax:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="130" data-line-first="131" style="display:block"><code data-line="131"><span style="color:purple">&lt;affect&gt;</span> ::= <span style="color:purple">&lt;var&gt;</span> &quot;=&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;set&gt;</span>)</code></pre>
<p class="p noindent para-continued" data-line="134"><span data-line="134"></span>This kind of affectation is global and applies for the whole code, even if the
affectation happens after the formulas when the variable appears. These
affectations are evaluated before any formula.
</p>
<p class="p indent" data-line="138"><span data-line="138"></span>The only place where the order of affectation has importance is when you want
to use a variable in an affectation expression. For example:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="140" data-line-first="141" style="display:block"><code data-line="141"><span style="color:purple">$N</span> = <span class="constant" style="color:purple">10</span>
<span style="color:purple">$set</span> = [<span class="constant" style="color:purple">1</span>..<span style="color:purple">$N</span>]    <span style="color:darkgreen">;; $N must be defined before $set</span></code></pre><h3 id="sec-variables" class="h2" data-line="145" data-heading-depth="2" style="display:block"><span data-line="145"></span><span class="heading-before"><span class="heading-label">2.3</span>.&#8194;</span><span data-line="145"></span>Variables</h3>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="147" data-line-first="148" style="display:block"><code data-line="148">TERM = [_0-9]*[a-zA-Z][a-zA-Z_0-9]*
<span style="color:purple">&lt;var&gt;</span> ::=
  | &quot;$&quot; TERM                            <span style="color:darkgreen">(* simple-var *)</span>
  | &quot;$&quot; TERM &quot;(&quot; <span style="color:purple">&lt;comma-list(&lt;float&gt;</span>|<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;prop&gt;)&gt;</span> &quot;)&quot; <span style="color:darkgreen">(* tuple-var *)</span></code></pre>
<dl class="dl compact" data-line="154">
<dt class="dt noindent dl-li compact-li" style="text-indent:0em;font-weight:bold">Simple variable (&#8220;simple-var&#8221;)</dt>
<dd class="dd" data-line="154" style="margin-left:1.5em"><span data-line="154"></span>A simple variable is of the form <span data-line="154"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$my_var</span></code><span data-line="154"></span>. In a formula, a simple
variable is always expected to be a proposition. In an expression, a simple
variable can contain an integer, a floating-point, a proposition, a boolean
or a set.
</dd>
<dt class="dt noindent dl-li compact-li" style="text-indent:0em;font-weight:bold">Tuple variable (can be seen as a <em class="em-low1">predicate</em>)</dt>
<dd class="dd" data-line="159" style="margin-left:1.5em"><span data-line="159"></span>A tuple variable is a simple variable followed by a comma-separated list of
indexes in braces, e.g., <span data-line="160"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$var</span>(<span style="color:purple">$i</span>,a,<span class="constant" style="color:purple">4</span>)</code><span data-line="160"></span>. The leading variable (<span data-line="160"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$var</span></code><span data-line="160"></span>)
must always contain a proposition. The nested indexes (e.g., <span data-line="161"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$i</span></code><span data-line="161"></span>) can be
integers, floats, propositions or booleans.
</dd>
<dd class="dd" data-line="164" style="margin-left:1.5em"><span data-line="164"></span>A tuple variable will always be expanded to a proposition. For example, if
<span data-line="165"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$var</span>=p</code><span data-line="165"></span> and <span data-line="165"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$i</span>=q</code><span data-line="165"></span>, then it will expand to <span data-line="165"></span><code class="code code2 language-touist lang-touist touist colorized">p(q,a,<span class="constant" style="color:purple">4</span>)</code><span data-line="165"></span>
</dd>
<dd class="dd" data-line="166" style="margin-left:1.5em"><span data-line="166"></span>Tuple variables are not (yet) compatible with the set-builder construct (in
<span data-line="167"></span><a href="#set-builder" title="2.7.3.&#8194;Set-builder notation" class="localref" style="target-element:h3"><span class="heading-label">2.7.3</span></a><span data-line="167"></span>). If one of the indexes is a set, the set will stay
as-is.</dd></dl>
<p class="p noindent" data-line="170"><span data-line="170"></span>Here are some examples of variables:
</p><table class="madoko block" data-line="172">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="172" data-row="0" data-col="1" style="text-align:center"></th><th class="thead tr-even col cell-line col-even col-last" data-line="172" data-row="0" data-col="2" style="text-align:center"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="173" data-row="1" data-col="1" style="font-weight:bold;text-align:center"><span data-line="173"></span> Simple-var  </th><th class="col thead tr-odd tr-last tr-first col-even col-last" data-line="173" data-row="1" data-col="2" style="font-weight:bold;text-align:center"><span data-line="173"></span> Tuple-var           </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1" style="text-align:center"></td><td class="tbody tr-even col cell-line col-even col-last" data-row="0" data-col="2" style="text-align:center"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="175" data-row="1" data-col="1" style="text-align:center"><span data-line="175"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$N</span></code><span data-line="175"></span>       </td><td class="tbody tr-odd tr-first col col-even col-last" data-line="175" data-row="1" data-col="2" style="text-align:center"><span data-line="175"></span> <span data-line="175"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$place</span>(<span style="color:purple">$number</span>)</code><span data-line="175"></span> </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="176" data-row="2" data-col="1" style="text-align:center"><span data-line="176"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$time</span></code><span data-line="176"></span>    </td><td class="tbody tr-even col col-even col-last" data-line="176" data-row="2" data-col="2" style="text-align:center"><span data-line="176"></span> <span data-line="176"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$action</span>(<span style="color:purple">$i</span>,<span style="color:purple">$j</span>)</code><span data-line="176"></span>  </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="177" data-row="3" data-col="1" style="text-align:center"><span data-line="177"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$SIZE</span></code><span data-line="177"></span>    </td><td class="tbody tr-odd col col-even col-last" data-line="177" data-row="3" data-col="2" style="text-align:center"><span data-line="177"></span>                     </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="178" data-row="4" data-col="1" style="text-align:center"><span data-line="178"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$is_over</span></code><span data-line="178"></span> </td><td class="tbody tr-even tr-last col col-even col-last" data-line="178" data-row="4" data-col="2" style="text-align:center"><span data-line="178"></span>                     </td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="179" data-row="4" data-col="1" style="text-align:center"></td><td class="tbody tr-even col cell-line col-even col-last" data-line="179" data-row="4" data-col="2" style="text-align:center"></td></tr></tbody></table><h3 id="sec-propositions" class="h2" data-line="181" data-heading-depth="2" style="display:block"><span data-line="181"></span><span class="heading-before"><span class="heading-label">2.4</span>.&#8194;</span><span data-line="181"></span>Propositions</h3>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="183" data-line-first="184" style="display:block"><code data-line="184">TERM = [_0-9]*[a-zA-Z][a-zA-Z_0-9]*
<span style="color:purple">&lt;prop&gt;</span> ::=
    | <span style="color:purple">&lt;var&gt;</span>
    | TERM
    | TERM &quot;(&quot; <span style="color:purple">&lt;comma-list(&lt;float&gt;</span> | <span style="color:purple">&lt;int&gt;</span> | <span style="color:purple">&lt;prop&gt;)&gt;</span> &quot;)&quot;</code></pre>
<p class="p noindent para-continued" data-line="191"><span data-line="191"></span>A simple proposition is a simple word that can contain numbers and the
underscore symbol (<span data-line="192"></span>&#8220;<code class="code code1">_</code>&#8221;<span data-line="192"></span>). A tuple proposition (we can it as a <span data-line="192"></span><em class="em-low1">predicate</em><span data-line="192"></span>),
of the form <span data-line="193"></span><code class="code code2 language-touist lang-touist touist colorized">prop(<span class="constant" style="color:purple">1</span>,<span style="color:purple">$i</span>,abc)</code><span data-line="193"></span>, must have indexes of type integer, float,
boolean or set.
</p><h4 id="tuple-prop-set" class="h3" data-line="196" data-heading-depth="3" style="display:block"><span data-line="196"></span><span class="heading-before"><span class="heading-label">2.4.1</span>.&#8194;</span><span data-line="196"></span>Tuple proposition containing a set</h4>
<p class="p noindent" data-line="198"><span data-line="198"></span>A tuple proposition that is in an expression and that contains at least one
set in its indexes will be expanded to a set of the cartesian product of the
set indexes. This feature is called <span data-line="200"></span><strong class="strong-star2">set-building</strong><span data-line="200"></span> and is described in
<span data-line="201"></span><a href="#set-builder" title="2.7.3.&#8194;Set-builder notation" class="localref" style="target-element:h3"><span class="heading-label">2.7.3</span></a><span data-line="201"></span> and only works in expressions (not in formulas).
</p>
<p class="p indent" data-line="203"><span data-line="203"></span>In the following table, the two right-columns show how the propositions
are expanded whether they are in an expression or in a formula:
</p>
<div class="center align-center" data-line="206" style="text-align:center"><table class="madoko block" data-line="207">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="207" data-row="0" data-col="1"></th><th class="thead tr-even col cell-line col-even" data-line="207" data-row="0" data-col="2"></th><th class="thead tr-even col cell-line col-odd col-last" data-line="207" data-row="0" data-col="3"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="208" data-row="1" data-col="1" style="font-weight:bold"><span data-line="208"></span> Proposition        </th><th class="col thead tr-odd tr-last tr-first col-even" data-line="208" data-row="1" data-col="2" style="font-weight:bold"><span data-line="208"></span> is in a formula     </th><th class="col thead tr-odd tr-last tr-first col-odd col-last" data-line="208" data-row="1" data-col="3" style="font-weight:bold"><span data-line="208"></span> is in an expression   </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-line col-even" data-row="0" data-col="2"></td><td class="tbody tr-even col cell-line col-odd col-last" data-row="0" data-col="3"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="210" data-row="1" data-col="1"><span data-line="210"></span> <span data-line="210"></span><code class="code code2 language-touist lang-touist touist colorized">p([a])</code><span data-line="210"></span>         </td><td class="tbody tr-odd tr-first col col-even" data-line="210" data-row="1" data-col="2"><span data-line="210"></span> <span data-line="210"></span><code class="code code2 language-touist lang-touist touist colorized">p([a])</code><span data-line="210"></span>          </td><td class="tbody tr-odd tr-first col col-odd col-last" data-line="210" data-row="1" data-col="3"><span data-line="210"></span> <span data-line="210"></span><code class="code code2 language-touist lang-touist touist colorized">p(a)</code><span data-line="210"></span>              </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="211" data-row="2" data-col="1"><span data-line="211"></span><code class="code code2 language-touist lang-touist touist colorized">p([a,b,c])</code><span data-line="211"></span>      </td><td class="tbody tr-even col col-even" data-line="211" data-row="2" data-col="2"><span data-line="211"></span> <span data-line="211"></span><code class="code code2 language-touist lang-touist touist colorized">p([a,b,c])</code><span data-line="211"></span>      </td><td class="tbody tr-even col col-odd col-last" data-line="211" data-row="2" data-col="3"><span data-line="211"></span><code class="code code2 language-touist lang-touist touist colorized">[p(a),p(b),p(c)]</code><span data-line="211"></span>   </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="212" data-row="3" data-col="1"><span data-line="212"></span><code class="code code2 language-touist lang-touist touist colorized">p([a,b],[<span class="constant" style="color:purple">1</span>..<span class="constant" style="color:purple">2</span>])</code><span data-line="212"></span> </td><td class="tbody tr-odd col col-even" data-line="212" data-row="3" data-col="2"><span data-line="212"></span> <span data-line="212"></span><code class="code code2 language-touist lang-touist touist colorized">p([a,b],[<span class="constant" style="color:purple">1</span>..<span class="constant" style="color:purple">2</span>])</code><span data-line="212"></span> </td><td class="tbody tr-odd col col-odd col-last" data-line="212" data-row="3" data-col="3"><span data-line="212"></span><code class="code code2 language-touist lang-touist touist colorized">[p(a,<span class="constant" style="color:purple">1</span>),p(b,<span class="constant" style="color:purple">1</span>)</code><span data-line="212"></span>     </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="213" data-row="4" data-col="1"><span data-line="213"></span>                    </td><td class="tbody tr-even tr-last col col-even" data-line="213" data-row="4" data-col="2"><span data-line="213"></span>                     </td><td class="tbody tr-even tr-last col col-odd col-last" data-line="213" data-row="4" data-col="3"><span data-line="213"></span> <span data-line="213"></span>&#160;<span data-line="213"></span> <span data-line="213"></span><code class="code code2 language-touist lang-touist touist colorized">p(a,<span class="constant" style="color:purple">2</span>),p(b,<span class="constant" style="color:purple">2</span>)]</code><span data-line="213"></span> </td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="214" data-row="4" data-col="1"></td><td class="tbody tr-even col cell-line col-even" data-line="214" data-row="4" data-col="2"></td><td class="tbody tr-even col cell-line col-odd col-last" data-line="214" data-row="4" data-col="3"></td></tr></tbody></table></div><h3 id="sec-numeric-expression" class="h2" data-line="219" data-heading-depth="2" style="display:block"><span data-line="219"></span><span class="heading-before"><span class="heading-label">2.5</span>.&#8194;</span><span data-line="219"></span>Numeric expression</h3>
<p class="p noindent" data-line="221"><span data-line="221"></span>The available operations on integers and floats are <span data-line="221"></span><code class="code code1">+</code><span data-line="221"></span>, <span data-line="221"></span><code class="code code1">-</code><span data-line="221"></span>, <span data-line="221"></span><code class="code code1">*</code><span data-line="221"></span>, <span data-line="221"></span><code class="code code1">/</code><span data-line="221"></span>,
<span data-line="222"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$x</span> <span style="color:blue">mod</span> <span style="color:purple">$y</span></code><span data-line="222"></span> (modulo) and <span data-line="222"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">abs</span>(<span style="color:purple">$x</span>)</code><span data-line="222"></span> (absolute value).
</p>
<p class="p indent" data-line="224"><span data-line="224"></span>Here is the complete rule for numeric operators:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="225" data-line-first="226" style="display:block"><code data-line="226"><span style="color:purple">&lt;num-operation(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;+&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;-&quot; <span style="color:purple">&lt;T&gt;</span>
    |     &quot;-&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;*&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;/&quot; <span style="color:purple">&lt;T&gt;</span>
<span style="color:purple">&lt;num-operation-others(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;mod&quot; <span style="color:purple">&lt;T&gt;</span>
    | &quot;abs(&quot; <span style="color:purple">&lt;T&gt;</span> &quot;)&quot;</code></pre>
<div class="note" data-line="237" style="display:block">
<p class="p noindent" data-line="238"><span data-line="238"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="239"></span>Integer and float expressions cannot be mixed. It is necessary to cast
explicitely to the other type when the types are not matching. For example,
the expression <span data-line="241"></span><code class="code code2 language-touist lang-touist touist colorized"><span class="constant" style="color:purple">1</span>+<span class="constant" style="color:purple">2.0</span></code><span data-line="241"></span> is  invalid and should be written <span data-line="241"></span><code class="code code2 language-touist lang-touist touist colorized"><span class="constant" style="color:purple">1</span>+<span style="color:blue">int</span>(<span class="constant" style="color:purple">2.0</span>)</code><span data-line="241"></span>
(gives an integer) or <span data-line="242"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">float</span>(<span class="constant" style="color:purple">1</span>)+<span class="constant" style="color:purple">2.0</span></code><span data-line="242"></span> (gives a float). Some operators are
specific to integer or float types:
</p>
<ul class="ul list-star compact" data-line="245">
<li class="li ul-li list-star-li compact-li" data-line="245"><span data-line="245"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">card</span>([a,b])</code><span data-line="245"></span> returns an integer,
</li>
<li class="li ul-li list-star-li compact-li" data-line="246"><span data-line="246"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">sqrt</span>(<span class="constant" style="color:purple">3</span>)</code><span data-line="246"></span> returns a float.</li></ul></div><h4 id="sec-integers" class="h3" data-line="248" data-heading-depth="3" style="display:block"><span data-line="248"></span><span class="heading-before"><span class="heading-label">2.5.1</span>.&#8194;</span><span data-line="248"></span>Integers</h4>
<p class="p noindent" data-line="249"><span data-line="249"></span>An integer constant <span data-line="249"></span><code class="code code1">INT</code><span data-line="249"></span> is a number that satisfies the regular expression
<span data-line="250"></span><code class="code code1">[0-9]+</code><span data-line="250"></span>. Here is the rule for writting correct integer expressions:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="251" data-line-first="252" style="display:block"><code data-line="252"><span style="color:purple">&lt;int&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | INT
    | num-operation(<span style="color:purple">&lt;int&gt;</span>)
    | num-operation-others(<span style="color:purple">&lt;int&gt;</span>)
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;int&gt;</span> &quot;else&quot; <span style="color:purple">&lt;int&gt;</span> &quot;end&quot;
    | &quot;int(&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>) &quot;)&quot;
    | &quot;card(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;</code></pre><h4 id="sec-floats" class="h3" data-line="263" data-heading-depth="3" style="display:block"><span data-line="263"></span><span class="heading-before"><span class="heading-label">2.5.2</span>.&#8194;</span><span data-line="263"></span>Floats</h4>
<p class="p noindent" data-line="264"><span data-line="264"></span>A floating-point constant <span data-line="264"></span><code class="code code1">FLOAT</code><span data-line="264"></span> is a number that satisfies the regular
expression <span data-line="265"></span><code class="code code1">[0-9]+\.[0-9]+</code><span data-line="265"></span>. The variants <span data-line="265"></span><code class="code code1">1.</code><span data-line="265"></span> or <span data-line="265"></span><code class="code code1">.1</code><span data-line="265"></span> are not accepted.
Here is the rule for writting correct integer expressions:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="267" data-line-first="268" style="display:block"><code data-line="268"><span style="color:purple">&lt;float&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;float&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | FLOAT
    | num-operation(<span style="color:purple">&lt;float&gt;</span>)
    | num-operation-others(<span style="color:purple">&lt;float&gt;</span>)
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;float&gt;</span> &quot;else&quot; <span style="color:purple">&lt;float&gt;</span> &quot;end&quot;
    | &quot;float(&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>)  &quot;)&quot;
    | &quot;sqrt(&quot; <span style="color:purple">&lt;float&gt;</span> &quot;)&quot;</code></pre><h3 id="sec-booleans" class="h2" data-line="279" data-heading-depth="2" style="display:block"><span data-line="279"></span><span class="heading-before"><span class="heading-label">2.6</span>.&#8194;</span><span data-line="279"></span>Booleans</h3>
<p class="p noindent" data-line="281"><span data-line="281"></span>The constants are <span data-line="281"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">true</span></code><span data-line="281"></span> and <span data-line="281"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">false</span></code><span data-line="281"></span>. The boolean connectors are <span data-line="281"></span><span class="math-inline">$&gt;$</span><span data-line="281"></span>, <span data-line="281"></span><span class="math-inline">$&lt;$</span><span data-line="281"></span>,
<span data-line="282"></span><span class="math-inline">$\ge$</span><span data-line="282"></span> (<span data-line="282"></span><code class="code code1">&gt;=</code><span data-line="282"></span>), <span data-line="282"></span><span class="math-inline">$\le$</span><span data-line="282"></span> (<span data-line="282"></span><code class="code code1">&lt;=</code><span data-line="282"></span>), <span data-line="282"></span><span class="math-inline">$=$</span><span data-line="282"></span> (<span data-line="282"></span><code class="code code1">==</code><span data-line="282"></span>) and <span data-line="282"></span><span class="math-inline">$\neq$</span><span data-line="282"></span> (<span data-line="282"></span><code class="code code1">!=</code><span data-line="282"></span>). The operators that
return a boolean are <span data-line="283"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">subset</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code><span data-line="283"></span>, <span data-line="283"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">empty</span>(<span style="color:purple">$P</span>)</code><span data-line="283"></span> and <span data-line="283"></span><code class="code code2 language-touist lang-touist touist colorized">p <span style="color:blue">in</span> <span style="color:purple">$P</span></code><span data-line="283"></span>:
</p>
<div class="center align-center" data-line="285" style="text-align:center"><table class="madoko block" data-line="286">
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-line col-even" data-row="0" data-col="2" style="text-align:center"></td><td class="tbody tr-even col cell-line col-odd col-last" data-row="0" data-col="3" style="text-align:right"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="287" data-row="1" data-col="1"><span data-line="287"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">subset</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code></td><td class="tbody tr-odd tr-first col col-even" data-line="287" data-row="1" data-col="2" style="text-align:center"><span data-line="287"></span><span class="math-inline">$P \subseteq Q$</span></td><td class="tbody tr-odd tr-first col col-odd col-last" data-line="287" data-row="1" data-col="3" style="text-align:right"><span data-line="287"></span><span class="math-inline">$P$</span><span data-line="287"></span> is a subset (or is included in) <span data-line="287"></span><span class="math-inline">$Q$</span><span data-line="287"></span> </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="288" data-row="2" data-col="1"><span data-line="288"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">empty</span>(<span style="color:purple">$P</span>)</code><span data-line="288"></span>    </td><td class="tbody tr-even col col-even" data-line="288" data-row="2" data-col="2" style="text-align:center"><span data-line="288"></span><span class="math-inline">$P=\emptyset$</span><span data-line="288"></span>  </td><td class="tbody tr-even col col-odd col-last" data-line="288" data-row="2" data-col="3" style="text-align:right"><span data-line="288"></span><span class="math-inline">$P$</span><span data-line="288"></span> is an empty set                     </td></tr>
<tr><td class="tbody tr-odd tr-last col col-odd col-first" data-line="289" data-row="3" data-col="1"><span data-line="289"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:purple">$i</span> <span style="color:blue">in</span> <span style="color:purple">$P</span></code><span data-line="289"></span>     </td><td class="tbody tr-odd tr-last col col-even" data-line="289" data-row="3" data-col="2" style="text-align:center"><span data-line="289"></span><span class="math-inline">$i \in P$</span><span data-line="289"></span>      </td><td class="tbody tr-odd tr-last col col-odd col-last" data-line="289" data-row="3" data-col="3" style="text-align:right"><span data-line="289"></span><span class="math-inline">$i$</span><span data-line="289"></span> is an element of the set <span data-line="289"></span><span class="math-inline">$P$</span><span data-line="289"></span>        </td></tr>
<tr><td class="tbody tr-odd col cell-line col-odd col-first" data-line="290" data-row="3" data-col="1"></td><td class="tbody tr-odd col cell-line col-even" data-line="290" data-row="3" data-col="2" style="text-align:center"></td><td class="tbody tr-odd col cell-line col-odd col-last" data-line="290" data-row="3" data-col="3" style="text-align:right"></td></tr></tbody></table></div>
<p class="p noindent" data-line="293"><span data-line="293"></span>Sets are detailed in<span data-line="293"></span>&nbsp;<a href="#sec-sets" title="2.7.&#8194;Sets" class="localref" style="target-element:h2"><span class="heading-label">2.7</span></a><span data-line="293"></span>.
</p>
<div id="dont-mix-bool-formula" class="note" data-line="295" style="display:block">
<p class="p noindent" data-line="296"><span data-line="296"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="297"></span>Booleans cannot be mixed with formulas. In a formula, the evaluation (choosing
true or false) is not done during the translation from touist to the
<span data-line="299"></span>&#8220;solver-friendly&#8221;<span data-line="299"></span> language. Conversely, a boolean expression must be
evaluable during the translation.</p></div>
<p class="p noindent" data-line="302"><span data-line="302"></span>Here is the full grammar rule for booleans:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="303" data-line-first="304" style="display:block"><code data-line="304"><span style="color:purple">&lt;bool&gt;</span> ::= &quot;(&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | &quot;true&quot;
    | &quot;false&quot;
    | (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>) &quot;in&quot; <span style="color:purple">&lt;set&gt;</span>
    | &quot;subset(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;empty(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;equality(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;)&gt;</span>
    | <span style="color:purple">&lt;order(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;)&gt;</span>
    | <span style="color:purple">&lt;connectors(&lt;bool&gt;)&gt;</span>
<span style="color:purple">&lt;equality(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;!=&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;==&quot; <span style="color:purple">&lt;T&gt;</span>
<span style="color:purple">&lt;order(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;&gt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;=&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&gt;=&quot; <span style="color:purple">&lt;T&gt;</span></code></pre><h3 id="sec-sets" class="h2" data-line="324" data-heading-depth="2" style="display:block"><span data-line="324"></span><span class="heading-before"><span class="heading-label">2.7</span>.&#8194;</span><span data-line="324"></span>Sets</h3>
<p class="p noindent" data-line="326"><span data-line="326"></span>Sets can contain anything (propositions, integers, floats, booleans
or even other sets) as long as all elements have the same type. There
exists three ways of creating a set:
</p><h4 id="sec-sets-defined-by-enumeration" class="h3" data-line="330" data-heading-depth="3" style="display:block"><span data-line="330"></span><span class="heading-before"><span class="heading-label">2.7.1</span>.&#8194;</span><span data-line="330"></span>Sets defined by enumeration</h4>
<p class="p noindent" data-line="331"><span data-line="331"></span><span class="math-inline">$\{1,3,8,10\}$</span><span data-line="331"></span> can be written <span data-line="331"></span><code class="code code2 language-touist lang-touist touist colorized">[<span class="constant" style="color:purple">1</span>,<span class="constant" style="color:purple">2</span>,<span class="constant" style="color:purple">3</span>]</code><span data-line="331"></span>. Elements can be integers, floats,
propositions, booleans or sets (or a variable of these five types).
The empty set <span data-line="333"></span><span class="math-inline">$\emptyset$</span><span data-line="333"></span> is denoted by <span data-line="333"></span><code class="code code2 language-touist lang-touist touist colorized">[]</code><span data-line="333"></span>.
</p><h4 id="sec-sets-defined-by-a-range" class="h3" data-line="335" data-heading-depth="3" style="display:block"><span data-line="335"></span><span class="heading-before"><span class="heading-label">2.7.2</span>.&#8194;</span><span data-line="335"></span>Sets defined by a range</h4>
<p class="p noindent" data-line="336"><span data-line="336"></span><span class="math-inline">$\{i~|~i=1,\dots,10\}$</span><span data-line="336"></span> can be written <span data-line="336"></span><code class="code code2 language-touist lang-touist touist colorized">[<span class="constant" style="color:purple">1</span>..<span class="constant" style="color:purple">10</span>]</code><span data-line="336"></span>. Ranges can
be produced with both integer and float limits. For both integer and float
limits, the step is 1 (it is not possible to change the step for now);
</p><h4 id="set-builder" class="h3" data-line="340" data-heading-depth="3" style="display:block"><span data-line="340"></span><span class="heading-before"><span class="heading-label">2.7.3</span>.&#8194;</span><span data-line="340"></span>Set-builder notation</h4>
<p class="p noindent" data-line="341"><span data-line="341"></span><span class="math-inline">$\{p(x_1,...,x_n)~|~(x_1,...,x_n) \in S_1 \times ... \times S_n \}$</span><span data-line="341"></span>, which the set
of tuple propositions based on the cartesian product of the sets <span data-line="342"></span><span class="math-inline">$S_1,...,S_n$</span><span data-line="342"></span>,
can be written <span data-line="343"></span><code class="code code2 language-touist lang-touist touist colorized">p(<span style="color:purple">$S1</span>,<span style="color:purple">$S2</span>,<span style="color:purple">$S3</span>)</code><span data-line="343"></span>. The example <span data-line="343"></span><code class="code code2 language-touist lang-touist touist colorized">p([a,b,c])</code><span data-line="343"></span> will produce
<span data-line="344"></span><code class="code code2 language-touist lang-touist touist colorized">[p(a),p(b),p(c)]</code><span data-line="344"></span>.
You can mix sets, integers, floats, propositions and booleans in indexes:
</p>
<div class="center align-center" data-line="346" style="text-align:center"><table class="madoko block" data-line="347">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="347" data-row="0" data-col="1"></th><th class="thead tr-even col cell-line col-even col-last" data-line="347" data-row="0" data-col="2" style="text-align:center"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="348" data-row="1" data-col="1" style="font-weight:bold"><span data-line="348"></span> Proposition             </th><th class="col thead tr-odd tr-last tr-first col-even col-last" data-line="348" data-row="1" data-col="2" style="font-weight:bold;text-align:center"><span data-line="348"></span> produces the set             </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-line col-even col-last" data-row="0" data-col="2" style="text-align:center"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="350" data-row="1" data-col="1"><span data-line="350"></span><code class="code code2 language-touist lang-touist touist colorized">f(<span class="constant" style="color:purple">1</span>,[a,b],[<span class="constant" style="color:purple">1.0</span>..<span class="constant" style="color:purple">2.0</span>])</code></td><td class="tbody tr-odd tr-first col col-even col-last" data-line="350" data-row="1" data-col="2" style="text-align:center"><span data-line="350"></span><code class="code code2 language-touist lang-touist touist colorized">[f(<span class="constant" style="color:purple">1</span>,a,<span class="constant" style="color:purple">1.0</span>),f(<span class="constant" style="color:purple">1</span>,a,<span class="constant" style="color:purple">2.0</span>),</code><span data-line="350"></span>   </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="351" data-row="2" data-col="1"><span data-line="351"></span>                         </td><td class="tbody tr-even tr-last col col-even col-last" data-line="351" data-row="2" data-col="2" style="text-align:center"><span data-line="351"></span> <span data-line="351"></span>&#160;<span data-line="351"></span><code class="code code2 language-touist lang-touist touist colorized">f(<span class="constant" style="color:purple">1</span>,b,<span class="constant" style="color:purple">1.0</span>),f(<span class="constant" style="color:purple">1</span>,b,<span class="constant" style="color:purple">2.0</span>)]</code><span data-line="351"></span> </td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="352" data-row="2" data-col="1"></td><td class="tbody tr-even col cell-line col-even col-last" data-line="352" data-row="2" data-col="2" style="text-align:center"></td></tr></tbody></table></div>
<p class="p noindent" data-line="354"><span data-line="354"></span><strong class="strong-star2">Important:</strong><span data-line="354"></span> the set-builder feature only works in expressions and does not
work in formulas. In formulas, the proposition <span data-line="355"></span><code class="code code2 language-touist lang-touist touist colorized">f([a,b])</code><span data-line="355"></span> will simply produce
<span data-line="356"></span><code class="code code2 language-touist lang-touist touist colorized">f([a,b])</code><span data-line="356"></span>. This also means that you can debug your sets by simply putting
your set in a tuple proposition.
</p>
<p class="p indent" data-line="359"><span data-line="359"></span>This notation is inspired from the concept of extension of a predicate (cf.
<span data-line="360"></span><a href="https://en.wikipedia.org/wiki/Extension_(predicate_logic)" data-linkid="predicate-ext">wikipedia</a><span data-line="360"></span>).
</p><h4 id="sec-operators-using-sets" class="h3" data-line="363" data-heading-depth="3" style="display:block"><span data-line="363"></span><span class="heading-before"><span class="heading-label">2.7.4</span>.&#8194;</span><span data-line="363"></span>Operators using sets</h4>
<p class="p noindent" data-line="365"><span data-line="365"></span>Four operators have been mentioned in previous sections; refer to these
sections to get description of each:
</p>
<ul class="ul list-star compact" data-line="368">
<li class="li ul-li list-star-li compact-li" data-line="368"><span data-line="368"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">card</span>(x)</code><span data-line="368"></span> (cf.<span data-line="368"></span>&nbsp;<a href="#sec-integers" title="2.5.1.&#8194;Integers" class="localref" style="target-element:h3"><span class="heading-label">2.5.1</span></a><span data-line="368"></span>), 
</li>
<li class="li ul-li list-star-li compact-li" data-line="369"><span data-line="369"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">empty</span>(<span style="color:purple">$S</span>)</code><span data-line="369"></span> (cf.<span data-line="369"></span>&nbsp;<a href="#sec-booleans" title="2.6.&#8194;Booleans" class="localref" style="target-element:h2"><span class="heading-label">2.6</span></a><span data-line="369"></span>),
</li>
<li class="li ul-li list-star-li compact-li" data-line="370"><span data-line="370"></span><code class="code code2 language-touist lang-touist touist colorized"><span class="constant" style="color:purple">1</span> <span style="color:blue">in</span> [<span class="constant" style="color:purple">1</span>,<span class="constant" style="color:purple">2</span>,<span class="constant" style="color:purple">3</span>]</code><span data-line="370"></span> (cf.<span data-line="370"></span>&nbsp;<a href="#sec-booleans" title="2.6.&#8194;Booleans" class="localref" style="target-element:h2"><span class="heading-label">2.6</span></a><span data-line="370"></span>),
</li>
<li class="li ul-li list-star-li compact-li" data-line="371"><span data-line="371"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">subset</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code><span data-line="371"></span> (cf.<span data-line="371"></span>&nbsp;<a href="#sec-booleans" title="2.6.&#8194;Booleans" class="localref" style="target-element:h2"><span class="heading-label">2.6</span></a><span data-line="371"></span>)
</li></ul>

<p class="p noindent" data-line="373"><span data-line="373"></span>Along with these four operators, some common set operators are available.
Let <span data-line="374"></span><span class="math-inline">$P$</span><span data-line="374"></span> and <span data-line="374"></span><span class="math-inline">$Q$</span><span data-line="374"></span> denote two sets:
</p>
<div class="center align-center" data-line="376" style="text-align:center"><table class="madoko block" data-line="377">
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-line col-even" data-row="0" data-col="2" style="text-align:center"></td><td class="tbody tr-even col cell-line col-odd col-last" data-row="0" data-col="3"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="378" data-row="1" data-col="1"><span data-line="378"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">inter</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code><span data-line="378"></span> </td><td class="tbody tr-odd tr-first col col-even" data-line="378" data-row="1" data-col="2" style="text-align:center"><span data-line="378"></span><span class="math-inline">$P \cap Q$</span><span data-line="378"></span>       </td><td class="tbody tr-odd tr-first col col-odd col-last" data-line="378" data-row="1" data-col="3"><span data-line="378"></span> intersection              </td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="379" data-row="2" data-col="1"><span data-line="379"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">union</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code><span data-line="379"></span> </td><td class="tbody tr-even col col-even" data-line="379" data-row="2" data-col="2" style="text-align:center"><span data-line="379"></span><span class="math-inline">$P \cup Q$</span><span data-line="379"></span>       </td><td class="tbody tr-even col col-odd col-last" data-line="379" data-row="2" data-col="3"><span data-line="379"></span> union                     </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="380" data-row="3" data-col="1"><span data-line="380"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">diff</span>(<span style="color:purple">$P</span>,<span style="color:purple">$Q</span>)</code><span data-line="380"></span>  </td><td class="tbody tr-odd col col-even" data-line="380" data-row="3" data-col="2" style="text-align:center"><span data-line="380"></span><span class="math-inline">$P \setminus Q$</span><span data-line="380"></span>  </td><td class="tbody tr-odd col col-odd col-last" data-line="380" data-row="3" data-col="3"><span data-line="380"></span> difference                </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="381" data-row="4" data-col="1"><span data-line="381"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">powerset</span>(<span style="color:purple">$Q</span>)</code><span data-line="381"></span> </td><td class="tbody tr-even tr-last col col-even" data-line="381" data-row="4" data-col="2" style="text-align:center"><span data-line="381"></span><span class="math-inline">$\mathcal{P}(Q)$</span><span data-line="381"></span> </td><td class="tbody tr-even tr-last col col-odd col-last" data-line="381" data-row="4" data-col="3"><span data-line="381"></span> powerset (cf.<span data-line="381"></span>&nbsp;<a href="#powerset" title="Powerset" class="localref" style="target-element:h4"><span class="heading-label">2.7.4.1</span></a><span data-line="381"></span>)</td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="382" data-row="4" data-col="1"></td><td class="tbody tr-even col cell-line col-even" data-line="382" data-row="4" data-col="2" style="text-align:center"></td><td class="tbody tr-even col cell-line col-odd col-last" data-line="382" data-row="4" data-col="3"></td></tr></tbody></table></div><h5 id="powerset" class="h4" data-line="385" data-heading-depth="4" style="display:block"><span data-line="385"></span>Powerset</h5>
<p class="p noindent para-continue" data-line="386"><span data-line="386"></span>The <span data-line="386"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">powerset</span>(<span style="color:purple">$Q</span>)</code><span data-line="386"></span> operator generates all possible subsets <span data-line="386"></span><span class="math-inline">$S$</span><span data-line="386"></span> such
that <span data-line="387"></span><span class="math-inline">$S \subseteq Q$</span><span data-line="387"></span>. It is defined as 
</p>
<div class="math para-block" data-line="388">
<div class="mathdisplay para-block input-math" data-math-full="" data-line="389" style="line-adjust:0"><span class="mathdisplay math-display" data-math-full="">\[\mathcal{P}(Q) := \{S~|~S\subseteq Q\}
\]</span></div></div>
<p class="p noindent para-continued" data-line="391"><span data-line="391"></span>The empty set is included in these subsets. Example:
<span data-line="392"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">powerset</span>([<span class="constant" style="color:purple">1</span>,<span class="constant" style="color:purple">2</span>])</code><span data-line="392"></span> generates <span data-line="392"></span><code class="code code2 language-touist lang-touist touist colorized">[[],[<span class="constant" style="color:purple">1</span>],[<span class="constant" style="color:purple">2</span>],[<span class="constant" style="color:purple">1</span>,<span class="constant" style="color:purple">2</span>]]</code><span data-line="392"></span>. 
</p>
<p class="p indent" data-line="394"><span data-line="394"></span>Here is the complete rule for sets:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="395" data-line-first="396" style="display:block"><code data-line="396"><span style="color:purple">&lt;set&gt;</span> ::= &quot;(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | &quot;[&quot; <span style="color:purple">&lt;comma-list(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;bool&gt;)&gt;</span> &quot;]&quot;
    | &quot;[ <span style="color:purple">&lt;int&gt;</span> &quot;..&quot; <span style="color:purple">&lt;int&gt;</span> &quot;]&quot;      <span style="color:darkgreen">&lt;- step is 1</span>
    | &quot;[ <span style="color:purple">&lt;float&gt;</span> &quot;..&quot; <span style="color:purple">&lt;float&gt;</span> &quot;]&quot;  <span style="color:darkgreen">&lt;- step is 1.0</span>
    | &quot;union(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;inter(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;diff(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;powerset(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;</code></pre><h3 id="sec-formulas" class="h2" data-line="407" data-heading-depth="2" style="display:block"><span data-line="407"></span><span class="heading-before"><span class="heading-label">2.8</span>.&#8194;</span><span data-line="407"></span>Formulas</h3><h4 id="sec-connectors" class="h3" data-line="409" data-heading-depth="3" style="display:block"><span data-line="409"></span><span class="heading-before"><span class="heading-label">2.8.1</span>.&#8194;</span><span data-line="409"></span>Connectors</h4>
<p class="p noindent" data-line="410"><span data-line="410"></span>A formula is a sequence of propositions (that can be variables) and connectors
<span data-line="411"></span><span class="math-inline">$\neg p$</span><span data-line="411"></span> (<span data-line="411"></span><code class="code code2 language-touist lang-touist touist colorized">not</code><span data-line="411"></span>), <span data-line="411"></span><span class="math-inline">$\wedge$</span><span data-line="411"></span> (<span data-line="411"></span><code class="code code2 language-touist lang-touist touist colorized">and</code><span data-line="411"></span>), <span data-line="411"></span><span class="math-inline">$\vee$</span><span data-line="411"></span> (<span data-line="411"></span><code class="code code2 language-touist lang-touist touist colorized">or</code><span data-line="411"></span>), <span data-line="411"></span><span class="math-inline">$\oplus$</span><span data-line="411"></span> (<span data-line="411"></span><code class="code code2 language-touist lang-touist touist colorized">xor</code><span data-line="411"></span>),
<span data-line="412"></span><span class="math-inline">$\rightarrow$</span><span data-line="412"></span> (<span data-line="412"></span><code class="code code2 language-touist lang-touist touist colorized">=&gt;</code><span data-line="412"></span>) or <span data-line="412"></span><span class="math-inline">$\leftrightarrow$</span><span data-line="412"></span> (<span data-line="412"></span><code class="code code2 language-touist lang-touist touist colorized">&lt;=&gt;</code><span data-line="412"></span>).
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="414" data-line-first="415" style="display:block"><code data-line="415"><span style="color:purple">&lt;connectors(&lt;T&gt;)&gt;</span> ::=
    |     &quot;not&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;and&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;or&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;xor&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;=&gt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;=&gt;&quot; <span style="color:purple">&lt;T&gt;</span></code></pre><h4 id="sec-generalized-connectors" class="h3" data-line="423" data-heading-depth="3" style="display:block"><span data-line="423"></span><span class="heading-before"><span class="heading-label">2.8.2</span>.&#8194;</span><span data-line="423"></span>Generalized connectors</h4>
<p class="p noindent" data-line="424"><span data-line="424"></span>Generalized connectors <span data-line="424"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigand</span></code><span data-line="424"></span>, <span data-line="424"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigor</span></code><span data-line="424"></span>, <span data-line="424"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">exact</span></code><span data-line="424"></span>, <span data-line="424"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">atmost</span></code><span data-line="424"></span> and
<span data-line="425"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">atleast</span></code><span data-line="425"></span> are also available for generalizing the formulas using sets. Here
is the rule for these:
</p>
<pre class="para-block margin pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="428" data-line-first="429" style="display:block"><code data-line="429"><span style="color:purple">&lt;generalized-connectors(&lt;T&gt;)&gt;</span> ::=
    | &quot;bigand&quot; <span style="color:purple">&lt;comma-list(&lt;var&gt;)&gt;</span> &quot;in&quot; <span style="color:purple">&lt;comma-list(&lt;set&gt;)&gt;</span>
                             [&quot;when&quot; <span style="color:purple">&lt;bool&gt;</span>] &quot;:&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | &quot;bigor&quot; <span style="color:purple">&lt;comma-list(&lt;var&gt;)&gt;</span> &quot;in&quot; <span style="color:purple">&lt;comma-list(&lt;set&gt;)&gt;</span>
                             [&quot;when&quot; <span style="color:purple">&lt;bool&gt;</span>] &quot;:&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | &quot;exact(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;atmost(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;atleast(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;</code></pre><h5 id="sec-bigand-and-bigor" class="h4" data-line="439" data-heading-depth="4" style="display:block"><span data-line="439"></span>Bigand and bigor</h5>
<p class="p noindent" data-line="441"><span data-line="441"></span>When multiple variables and sets are given, the <span data-line="441"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigand</span></code><span data-line="441"></span> and <span data-line="441"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigor</span></code><span data-line="441"></span>
operators will produce the <span data-line="442"></span><code class="code code2 language-touist lang-touist touist colorized">and</code><span data-line="442"></span>/<span data-line="442"></span><code class="code code2 language-touist lang-touist touist colorized">or</code><span data-line="442"></span> sequence for each possible couple of
value of each set (the set of couples is the Cartesian product of the given
sets). For example,
</p>
<div class="center align-center" data-line="446" style="text-align:center"><table class="madoko block" data-line="447">
<thead><tr><th class="thead tr-even col cell-line col-odd col-first" data-line="447" data-row="0" data-col="1"></th><th class="thead tr-even col cell-border-left cell-line col-even col-last" data-line="447" data-row="0" data-col="2"></th></tr>
<tr><th class="col thead tr-odd tr-last tr-first col-odd col-first" data-line="448" data-row="1" data-col="1" style="font-weight:bold"><span data-line="448"></span> The formula                                                              </th><th class="col cell-border-left thead tr-odd tr-last tr-first col-even col-last" data-line="448" data-row="1" data-col="2" style="font-weight:bold"><span data-line="448"></span> expands to<span data-line="448"></span>&#8230;<span data-line="448"></span>                                          </th></tr></thead>
<tbody><tr><td class="tbody tr-even col cell-line col-odd col-first" data-row="0" data-col="1"></td><td class="tbody tr-even col cell-border-left cell-line col-even col-last" data-row="0" data-col="2"></td></tr>
<tr><td class="tbody tr-odd tr-first col col-odd col-first" data-line="450" data-row="1" data-col="1"><span data-line="450"></span> <span data-line="450"></span><span class="math-inline">$\bigwedge\limits_{\substack{i\in \{1,...,2\}\\j \in \{a,b\}}} p_{i,j}$</span><span data-line="450"></span> </td><td class="tbody tr-odd tr-first col cell-border-left col-even col-last" data-line="450" data-row="1" data-col="2"><span data-line="450"></span> <span data-line="450"></span><span class="math-inline">$p_{1,a} \wedge p_{1,b} \wedge p_{2,a} \wedge p_{2,b}$</span><span data-line="450"></span> </td></tr>
<tr><td class="tbody tr-odd tr-first col cell-line col-odd col-first" data-line="451" data-row="1" data-col="1"></td><td class="tbody tr-odd tr-first col cell-border-left cell-line col-even col-last" data-line="451" data-row="1" data-col="2"></td></tr>
<tr><td class="tbody tr-even col col-odd col-first" data-line="452" data-row="2" data-col="1"><span data-line="452"></span> <span data-line="452"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigand</span> <span style="color:purple">$i</span>,<span style="color:purple">$j</span> <span style="color:blue">in</span> [<span class="constant" style="color:purple">1</span>..<span class="constant" style="color:purple">2</span>],[a,b]:</code><span data-line="452"></span>                                        </td><td class="tbody tr-even col cell-border-left col-even col-last" data-line="452" data-row="2" data-col="2"><span data-line="452"></span> <span data-line="452"></span><code class="code code2 language-touist lang-touist touist colorized">p(<span class="constant" style="color:purple">1</span>,a) and p(<span class="constant" style="color:purple">1</span>,b) </code><span data-line="452"></span>                                 </td></tr>
<tr><td class="tbody tr-odd col col-odd col-first" data-line="453" data-row="3" data-col="1"><span data-line="453"></span> <span data-line="453"></span><code class="code code2 language-touist lang-touist touist colorized">p(<span style="color:purple">$i</span>,<span style="color:purple">$j</span>)</code><span data-line="453"></span>                                                             </td><td class="tbody tr-odd col cell-border-left col-even col-last" data-line="453" data-row="3" data-col="2"><span data-line="453"></span> <span data-line="453"></span><code class="code code2 language-touist lang-touist touist colorized">and p(<span class="constant" style="color:purple">2</span>,a) and p(<span class="constant" style="color:purple">2</span>,b)</code><span data-line="453"></span>                              </td></tr>
<tr><td class="tbody tr-even tr-last col col-odd col-first" data-line="454" data-row="4" data-col="1"><span data-line="454"></span> <span data-line="454"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">end</span></code><span data-line="454"></span>                                                                  </td><td class="tbody tr-even tr-last col cell-border-left col-even col-last" data-line="454" data-row="4" data-col="2"><span data-line="454"></span>                                                        </td></tr>
<tr><td class="tbody tr-even col cell-line col-odd col-first" data-line="455" data-row="4" data-col="1"></td><td class="tbody tr-even col cell-border-left cell-line col-even col-last" data-line="455" data-row="4" data-col="2"></td></tr></tbody></table></div>
<p class="p noindent" data-line="458"><span data-line="458"></span>The <span data-line="458"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">when</span></code><span data-line="458"></span> is optional and allows to apply a condition to each couple of
valued variable.
</p>
<p class="p indent" data-line="461"><span data-line="461"></span>On the following two examples, the math expression is given on the left
and the matching touist code is given on the right:
</p><table class="columns block" data-line="464">
<tbody><tr><td class="column" data-line="465" style="width:40%">
<p class="p noindent" data-line="466"><span data-line="466"></span><span class="math-inline">$\bigwedge\limits_{\substack{i\in [1..n]\\j \in [a,b,c]}} p_{i,j}$</span></p></td><td class="column" data-line="468">
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="469" data-line-first="470" style="display:block"><code data-line="470"><span style="color:blue">bigand</span> <span style="color:purple">$i</span>,<span style="color:purple">$j</span> <span style="color:blue">in</span> [<span class="constant" style="color:purple">1</span>..<span style="color:purple">$n</span>],[a,b,c]:
    p(<span style="color:purple">$i</span>,<span style="color:purple">$j</span>)
<span style="color:blue">end</span></code></pre></td></tr></tbody></table><table class="columns block" data-line="476">
<tbody><tr><td class="column" data-line="477" style="width:40%">
<p class="p noindent" data-line="478"><span data-line="478"></span><span class="math-inline">$\bigvee\limits_{\substack{v\in [A,B,C]\\x \in [1..9]\\y\in[3..4]\\x \ne y \\ x \ne A\\}} v_{x,y}$</span></p></td><td class="column" data-line="480">
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="481" data-line-first="482" style="display:block"><code data-line="482"><span style="color:blue">bigor</span> <span style="color:purple">$v</span>,<span style="color:purple">$x</span>,<span style="color:purple">$y</span>
      <span style="color:blue">in</span> [A,B,C],[<span class="constant" style="color:purple">1</span>..<span class="constant" style="color:purple">9</span>],[<span class="constant" style="color:purple">3</span>..<span class="constant" style="color:purple">4</span>] 
      <span style="color:blue">when</span> <span style="color:purple">$v</span>!=A and <span style="color:purple">$x</span>!=<span style="color:purple">$y</span>:
    <span style="color:purple">$v</span>(<span style="color:purple">$x</span>)
<span style="color:blue">end</span></code></pre></td></tr></tbody></table><h5 id="sec-exact-atmost-and-atleast" class="h4" data-line="491" data-heading-depth="4" style="display:block"><span data-line="491"></span>Exact, atmost and atleast</h5>
<p class="p noindent" data-line="493"><span data-line="493"></span>The operator <span data-line="493"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">exact</span>(<span class="constant" style="color:purple">3</span>,[a,b,c,d,e])</code><span data-line="493"></span> will produce the formula that ensures
that, for any valuation, exactly 3 propositions can be <span data-line="494"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">true</span></code><span data-line="494"></span> simultaneously.
The operator <span data-line="495"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">atleast</span></code><span data-line="495"></span> ensures that at least N propositions are <span data-line="495"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">true</span></code><span data-line="495"></span>
simultanously, and <span data-line="496"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">atmost</span></code><span data-line="496"></span> does the opposite.
</p>
<div class="note" data-line="498" style="display:block">
<p class="p noindent" data-line="499"><span data-line="499"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="500"></span>(TODO) explain the cases N=0 or empty set</p></div><h4 id="sec-propositional-logic-formulas" class="h3" data-line="502" data-heading-depth="3" style="display:block"><span data-line="502"></span><span class="heading-before"><span class="heading-label">2.8.3</span>.&#8194;</span><span data-line="502"></span>Propositional logic formulas</h4>
<p class="p noindent" data-line="504"><span data-line="504"></span>The constants <span data-line="504"></span><span class="math-inline">$\top$</span><span data-line="504"></span> (<span data-line="504"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">Top</span></code><span data-line="504"></span>) and <span data-line="504"></span><span class="math-inline">$\bot$</span><span data-line="504"></span> (<span data-line="504"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">Bot</span></code><span data-line="504"></span>) allows to express the
<span data-line="505"></span>&#8220;always true&#8221;<span data-line="505"></span> and <span data-line="505"></span>&#8220;always false&#8221;<span data-line="505"></span>. Here is the complete grammar:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="507" data-line-first="508" style="display:block"><code data-line="508"><span style="color:purple">&lt;formula-simple&gt;</span> ::=
    | &quot;Top&quot;
    | &quot;Bot&quot;
    | <span style="color:purple">&lt;prop&gt;</span>
    | <span style="color:purple">&lt;var&gt;</span>
    | <span style="color:purple">&lt;formula(&lt;formula-simple&gt;)&gt;</span>

<span style="color:purple">&lt;formula(&lt;T&gt;)&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;T&gt;</span> &quot;)&quot;
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;T&gt;</span> &quot;else&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | <span style="color:purple">&lt;connectors(&lt;T&gt;)&gt;</span>
    | <span style="color:purple">&lt;generalized-connectors(&lt;T&gt;)&gt;</span>
    | <span style="color:purple">&lt;let-affect(&lt;T&gt;)&gt;</span>
</code></pre><h4 id="sec-smt-formulas" class="h3" data-line="523" data-heading-depth="3" style="display:block"><span data-line="523"></span><span class="heading-before"><span class="heading-label">2.8.4</span>.&#8194;</span><span data-line="523"></span>SMT formulas</h4>
<p class="p noindent" data-line="525"><span data-line="525"></span>Touist can also be given Satisfiability Modulo Theory (SMT) formulas and output
the SMT2-LIB-compliant file.
(TODO)
</p><h4 id="sec-local-variables" class="h3" data-line="529" data-heading-depth="3" style="display:block"><span data-line="529"></span><span class="heading-before"><span class="heading-label">2.8.5</span>.&#8194;</span><span data-line="529"></span>Local variables</h4>
<p class="p noindent" data-line="530"><span data-line="530"></span>Sometimes, you want to use the same result in multiple places. You might not be
able to use a global affectation (presented in<span data-line="531"></span>&nbsp;<a href="#affect" title="2.2.&#8194;Affectations" class="localref" style="target-element:h2"><span class="heading-label">2.2</span></a><span data-line="531"></span>) because you are in a
nested formula. The <span data-line="532"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">let</span></code><span data-line="532"></span> construct lets you create temporary variables
inside formulas:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="534" data-line-first="535" style="display:block"><code data-line="535"><span style="color:purple">&lt;let-affect&lt;T&gt;&gt;</span> ::=
    | &quot;let&quot; <span style="color:purple">&lt;var&gt;</span> &quot;=&quot; <span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;set&gt;</span> &quot;:&quot; <span style="color:purple">&lt;formula&lt;T&gt;&gt;</span></code></pre>
<p class="p noindent para-continued" data-line="539"><span data-line="539"></span>Example: 
</p>
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="540" data-line-first="541" style="display:block"><code data-line="541"><span style="color:darkgreen">;; This piece of code has no actual meaning</span>
<span style="color:purple">$letters</span> = [a,b,c,d,e]
<span style="color:blue">bigand</span> <span style="color:purple">$letter</span>,<span style="color:purple">$number</span> <span style="color:blue">in</span> <span style="color:purple">$letters</span>,[<span class="constant" style="color:purple">1</span>..<span style="color:blue">card</span>(<span style="color:purple">$letters</span>)]:
  has(<span style="color:purple">$letter</span>,<span style="color:purple">$number</span>) =&gt;
  <span style="color:blue">let</span> <span style="color:purple">$without_letter</span> = <span style="color:blue">diff</span>(<span style="color:purple">$letters</span>,<span style="color:purple">$letter</span>): <span style="color:darkgreen">;; keep temorary result</span>
  <span style="color:blue">bigand</span> <span style="color:purple">$l1</span> <span style="color:blue">in</span> <span style="color:purple">$without_letter</span>:
      p(<span style="color:purple">$letter</span>) 
  <span style="color:blue">end</span>
<span style="color:blue">end</span></code></pre><h3 id="sec-formal-grammar" class="h2" data-line="553" data-heading-depth="2" style="display:block"><span data-line="553"></span><span class="heading-before"><span class="heading-label">2.9</span>.&#8194;</span><span data-line="553"></span>Formal grammar</h3>
<p class="p noindent" data-line="555"><span data-line="555"></span>This section presents the grammar formatted in a BNF-like way. Some rules (a
rule begins with <span data-line="556"></span>&#8220;<code class="code code1">::=</code>&#8221;<span data-line="556"></span>) are parametrized so that some parts of the grammar
are <span data-line="557"></span>&#8220;factorized&#8221;<span data-line="557"></span> (the idea of parametrized rules come from the Menhir parser
generator used for generating the touist parser).
</p>
<div class="note" data-line="560" style="display:block">
<p class="p noindent" data-line="561"><span data-line="561"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="562"></span>This grammar specification is not LL(1) and could not be implemented as such
using Menhir; most of the type checking is made after the abstract syntactic
tree is produced. The only purpose of the present specification is to give a
clear view of what is possible and not possible with this language.</p></div>
<pre class="para-block serif pretty pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="567" data-line-first="568" style="display:block;font-size:100%"><code data-line="568"><table class="block" data-line="568">
<tbody><tr><td class='colspan1 expander'>INT       = [0-9]+</td></tr>
<tr><td class='colspan1 expander'>FLOAT     = [0-9]+\.[0-9]+</td></tr>
<tr><td class='colspan1 expander'>TERM      = [_0-9]*[a-zA-Z][a-zA-Z_0-9]*</td></tr></tbody></table></code></pre>
<pre class="para-block pre-fenced pre-fenced3 language-grammar lang-grammar grammar colorized" data-line="573" data-line-first="574" style="display:block"><code data-line="574"><span style="color:purple">&lt;touist-file&gt;</span> ::= <span style="color:purple">&lt;affect&gt;</span> <span style="color:purple">&lt;touist-file&gt;</span>
                 | <span style="color:purple">&lt;formula&gt;</span> <span style="color:purple">&lt;touist-file&gt;</span>
                 | EOF

<span style="color:purple">&lt;var&gt;</span> ::= &quot;$&quot; TERM
    | &quot;$&quot; TERM &quot;(&quot; <span style="color:purple">&lt;comma-list(&lt;float&gt;</span> | <span style="color:purple">&lt;int&gt;</span> | <span style="color:purple">&lt;prop&gt;)&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;prop&gt;</span> ::=
    | <span style="color:purple">&lt;var&gt;</span>
    | TERM
    | TERM &quot;(&quot; <span style="color:purple">&lt;comma-list(&lt;float&gt;</span> | <span style="color:purple">&lt;int&gt;</span> | <span style="color:purple">&lt;prop&gt;)&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;affect&gt;</span> ::= <span style="color:purple">&lt;var&gt;</span> &quot;=&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;set&gt;</span>)

<span style="color:purple">&lt;let-affect&lt;T&gt;&gt;</span> ::=
    | &quot;let&quot; <span style="color:purple">&lt;var&gt;</span> &quot;=&quot; <span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;set&gt;</span> &quot;:&quot; <span style="color:purple">&lt;formula&lt;T&gt;&gt;</span>

<span style="color:purple">&lt;equality(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;!=&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;==&quot; <span style="color:purple">&lt;T&gt;</span>

<span style="color:purple">&lt;order(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;&gt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;=&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&gt;=&quot; <span style="color:purple">&lt;T&gt;</span>

<span style="color:purple">&lt;bool&gt;</span> ::= &quot;(&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | &quot;true&quot;
    | &quot;false&quot;
    | (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;bool&gt;</span>) &quot;in&quot; <span style="color:purple">&lt;set&gt;</span>
    | &quot;subset(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;empty(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;equality(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;)&gt;</span>
    | <span style="color:purple">&lt;order(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;)&gt;</span>
    | <span style="color:purple">&lt;connectors(&lt;bool&gt;)&gt;</span>

<span style="color:purple">&lt;num-operation(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;+&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;-&quot; <span style="color:purple">&lt;T&gt;</span>
    |     &quot;-&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;*&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;/&quot; <span style="color:purple">&lt;T&gt;</span>

<span style="color:purple">&lt;num-operation-others(&lt;T&gt;)&gt;</span> ::=
    | <span style="color:purple">&lt;T&gt;</span> &quot;mod&quot; <span style="color:purple">&lt;T&gt;</span>
    | &quot;abs(&quot; <span style="color:purple">&lt;T&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;int&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | INT
    | num-operation(<span style="color:purple">&lt;int&gt;</span>)
    | num-operation-others(<span style="color:purple">&lt;int&gt;</span>)
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;int&gt;</span> &quot;else&quot; <span style="color:purple">&lt;int&gt;</span> &quot;end&quot;
    | &quot;int(&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>) &quot;)&quot;
    | &quot;card(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;float&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;float&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | FLOAT
    | num-operation(<span style="color:purple">&lt;float&gt;</span>)
    | num-operation-others(<span style="color:purple">&lt;float&gt;</span>)
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;float&gt;</span> &quot;else&quot; <span style="color:purple">&lt;float&gt;</span> &quot;end&quot;
    | &quot;float(&quot; (<span style="color:purple">&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>)  &quot;)&quot;
    | &quot;sqrt(&quot; <span style="color:purple">&lt;float&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;set&gt;</span> ::= &quot;(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | <span style="color:purple">&lt;var&gt;</span>
    | &quot;[&quot; <span style="color:purple">&lt;comma-list(&lt;int&gt;</span>|<span style="color:purple">&lt;float&gt;</span>|<span style="color:purple">&lt;prop&gt;</span>|<span style="color:purple">&lt;bool&gt;)&gt;</span> &quot;]&quot;
    | &quot;[ <span style="color:purple">&lt;int&gt;</span> &quot;..&quot; <span style="color:purple">&lt;int&gt;</span> &quot;]&quot;      <span style="color:darkgreen">&lt;- step is 1</span>
    | &quot;[ <span style="color:purple">&lt;float&gt;</span> &quot;..&quot; <span style="color:purple">&lt;float&gt;</span> &quot;]&quot;  <span style="color:darkgreen">&lt;- step is 1.0</span>
    | &quot;union(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot; 
    | &quot;inter(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;diff(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;powerset(&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;comma-list(&lt;T&gt;)&gt;</span> ::= <span style="color:purple">&lt;T&gt;</span> | <span style="color:purple">&lt;T&gt;</span> &quot;,&quot; <span style="color:purple">&lt;comma-list(&lt;T&gt;)&gt;</span>

<span style="color:purple">&lt;generalized-connectors(&lt;T&gt;)&gt;</span> ::=
    | &quot;bigand&quot; <span style="color:purple">&lt;comma-list(&lt;var&gt;)&gt;</span> &quot;in&quot; <span style="color:purple">&lt;comma-list(&lt;set&gt;)&gt;</span>
                             [&quot;when&quot; <span style="color:purple">&lt;bool&gt;</span>] &quot;:&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | &quot;bigor&quot; <span style="color:purple">&lt;comma-list(&lt;var&gt;)&gt;</span> &quot;in&quot; <span style="color:purple">&lt;comma-list(&lt;set&gt;)&gt;</span>
                             [&quot;when&quot; <span style="color:purple">&lt;bool&gt;</span>] &quot;:&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | &quot;exact(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;atmost(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;
    | &quot;atleast(&quot; <span style="color:purple">&lt;int&gt;</span> &quot;,&quot; <span style="color:purple">&lt;set&gt;</span> &quot;)&quot;

<span style="color:purple">&lt;connectors(&lt;T&gt;)&gt;</span> ::=
    |     &quot;not&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;and&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;or&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;xor&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;=&gt;&quot; <span style="color:purple">&lt;T&gt;</span>
    | <span style="color:purple">&lt;T&gt;</span> &quot;&lt;=&gt;&quot; <span style="color:purple">&lt;T&gt;</span>

<span style="color:purple">&lt;formula(&lt;T&gt;)&gt;</span> ::=
    | &quot;(&quot; <span style="color:purple">&lt;T&gt;</span> &quot;)&quot;
    | &quot;if&quot; <span style="color:purple">&lt;bool&gt;</span> &quot;then&quot; <span style="color:purple">&lt;T&gt;</span> &quot;else&quot; <span style="color:purple">&lt;T&gt;</span> &quot;end&quot;
    | <span style="color:purple">&lt;connectors(&lt;T&gt;)&gt;</span>
    | <span style="color:purple">&lt;generalized-connectors(&lt;T&gt;)&gt;</span>
    | <span style="color:purple">&lt;let-affect(&lt;T&gt;)&gt;</span>

<span style="color:purple">&lt;formula-simple&gt;</span> ::=
    | &quot;Top&quot;
    | &quot;Bot&quot;
    | <span style="color:purple">&lt;prop&gt;</span>
    | <span style="color:purple">&lt;var&gt;</span>
    | <span style="color:purple">&lt;formula(&lt;formula-simple&gt;)&gt;</span>

<span style="color:purple">&lt;formula-smt&gt;</span> ::=
    | <span style="color:purple">&lt;formula(&lt;formula-smt&gt;)&gt;</span>
    | <span style="color:purple">&lt;expr-smt&gt;</span>

<span style="color:purple">&lt;expr-smt&gt;</span> ::=
    | &quot;Top&quot;
    | &quot;Bot&quot;
    | <span style="color:purple">&lt;prop&gt;</span>
    | <span style="color:purple">&lt;var&gt;</span>
    | <span style="color:purple">&lt;int&gt;</span>
    | <span style="color:purple">&lt;float&gt;</span>
    | <span style="color:purple">&lt;order&gt;(&lt;expr-smt&gt;</span>)
    | &lt;num-operations_standard(<span style="color:purple">&lt;expr-smt&gt;)&gt;</span>
    | <span style="color:purple">&lt;equality(&lt;expr-smt&gt;)&gt;</span>
    | &lt;in_parenthesis(<span style="color:purple">&lt;expr-smt&gt;)&gt;</span></code></pre><h2 id="sec-command-line-tool-touist" class="h1" data-line="703" data-heading-depth="1" style="display:block"><span data-line="703"></span><span class="heading-before"><span class="heading-label">3</span>.&#8194;</span><span data-line="703"></span>Command-line tool (<span data-line="703"></span><code class="code code1">touist</code><span data-line="703"></span>)</h2><h3 id="sec-installation" class="h2" data-line="705" data-heading-depth="2" style="display:block"><span data-line="705"></span><span class="heading-before"><span class="heading-label">3.1</span>.&#8194;</span><span data-line="705"></span>Installation</h3>
<p class="p noindent" data-line="706"><span data-line="706"></span>The main tool that parses and solves the touist programs is written in Ocaml.
It is easily installable (as long as you have installed <span data-line="707"></span><code class="code code1">ocaml</code><span data-line="707"></span> and <span data-line="707"></span><code class="code code1">opam</code><span data-line="707"></span>)
with the command
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="709" data-line-first="710" style="display:block"><code data-line="710">  opam install touist</code></pre>
<div class="note" data-line="713" style="display:block">
<p class="p noindent" data-line="714"><span data-line="714"></span><span class="note-before"><strong class="strong-star2"><span class="note-caption">Note</span></strong>.
</span><span data-line="715"></span><code class="code code1">touist</code><span data-line="715"></span> can only solve SAT problems (written using propositional logic).
Problems written using the Satisfiability Modulo Theory (SMT) extension of
<span data-line="717"></span><code class="code code1">touist</code><span data-line="717"></span> cannot (yet) be solved, but can still be translated to the SMT2-LIB
format which can then be fed to a SMT solver.</p></div><h3 id="cli" class="h2" data-line="720" data-heading-depth="2" style="display:block"><span data-line="720"></span><span class="heading-before"><span class="heading-label">3.2</span>.&#8194;</span><span data-line="720"></span>Usage</h3>
<p class="p noindent" data-line="722"><span data-line="722"></span>Any touist command is of the form:
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="723" data-line-first="724" style="display:block"><code data-line="724">  touist [-o OUTPUT] (INPUT | -) [options...]</code></pre>
<p class="p noindent para-continued" data-line="726"><span data-line="726"></span>The flags can be given in any order. You can use the standard input
(<span data-line="727"></span><code class="code code1">stdin</code><span data-line="727"></span>) instead of using an input file by setting the <span data-line="727"></span><code class="code code1">-</code><span data-line="727"></span> argument.
With no <span data-line="728"></span><code class="code code1">-o</code><span data-line="728"></span> flag, touist will output to the standard output (<span data-line="728"></span><code class="code code1">stdout</code><span data-line="728"></span>).
</p><h4 id="sec-usage-for-propositional-logic-sat-mode" class="h3" data-line="730" data-heading-depth="3" style="display:block"><span data-line="730"></span><span class="heading-before"><span class="heading-label">3.2.1</span>.&#8194;</span><span data-line="730"></span>Usage for propositional logic (SAT mode)</h4>
<p class="p noindent" data-line="732"><span data-line="732"></span>The language accepted for propositional logic is described in
<span data-line="733"></span><a href="#sec-propositional-logic-formulas" title="2.8.3.&#8194;Propositional logic formulas" class="localref" style="target-element:h3"><span class="heading-label">2.8.3</span></a><span data-line="733"></span>. This mode is enabled by
default, but can be optionally expressed using the <span data-line="734"></span><code class="code code1">--sat</code><span data-line="734"></span> flag.
</p>
<p class="p indent" data-line="736"><span data-line="736"></span>With no other argument, touist will simply translate the touist
code to the<span data-line="737"></span>&nbsp;<a href="http://www.satcompetition.org/2009/format-benchmarks2009.html" data-linkid="dimacs">DIMACS</a><span data-line="737"></span> format and then output the mapping table
(that maps each proposition to an integer <span data-line="738"></span>&gt;<span data-line="738"></span> 0) in DIMACS comments.
You can redirect this mapping table using the <span data-line="739"></span><code class="code code1">--table &lt;filename&gt;</code><span data-line="739"></span> flag. 
</p><h5 id="sec-options-" class="h4" data-line="742" data-heading-depth="4" style="display:block"><span data-line="742"></span>Options:</h5>
<p class="p noindent" data-line="744"><span data-line="744"></span><strong class="strong-star2"><code class="code code1">--solve</code></strong><span data-line="744"></span>. Ask touist to solve the SAT problem. By default, the first
model is displayed; you can ask for more models using the <span data-line="745"></span><code class="code code1">--limit N</code><span data-line="745"></span>
option. The models are separated by lines beginning with <span data-line="746"></span><code class="code code1">====</code><span data-line="746"></span> and
for one model, each line contains a valuation followed by the corresponding
proposition. For example:
</p>
<pre class="para-block pre-fenced pre-fenced3 language-touist lang-touist touist colorized" data-line="749" data-line-first="750" style="display:block"><code data-line="750">  echo a and b | touist - --solve</code></pre>
<p class="p noindent para-continued" data-line="752"><span data-line="752"></span>will display
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="753" data-line-first="754" style="display:block"><code data-line="754">  ==== model 0
  1 b
  1 a
  ==== Found 1 models, limit is 1 (--limit N for more models)</code></pre>
<p class="p noindent para-continued" data-line="759"><span data-line="759"></span>which corresponds to the valuation <span data-line="759"></span><span class="math-inline">$\{a \leftarrow 1, b \leftarrow 1\}$</span><span data-line="759"></span>. Note
that the model counter begins at 0. With this format, you can easily filter
the results. For example, the following command will only show the propositions
that are <span data-line="762"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">true</span></code><span data-line="762"></span>:
</p>
<pre class="para-block pre-fenced pre-fenced3" data-line="763" data-line-first="764" style="display:block"><code data-line="764">  echo a and b | touist - --solve | grep ^1</code></pre>
<p class="p noindent para-continued" data-line="767"><span data-line="767"></span><strong class="strong-star2"><code class="code code1">--limit N</code></strong><span data-line="767"></span>. In conjunction with <span data-line="767"></span><code class="code code1">--solve</code><span data-line="767"></span>, set the maximum number
of models returned. When N=0, all models are returned.
</p>
<p class="p indent" data-line="770"><span data-line="770"></span><strong class="strong-star2"><code class="code code1">--count</code></strong><span data-line="770"></span>. Instead of returning the models, just return the count
of models. This option will only work for small problems: the number of
models explodes when the number of propositions is big.
</p><h4 id="sec-other-options" class="h3" data-line="774" data-heading-depth="3" style="display:block"><span data-line="774"></span><span class="heading-before"><span class="heading-label">3.2.2</span>.&#8194;</span><span data-line="774"></span>Other options</h4>
<p class="p noindent" data-line="775"><span data-line="775"></span><strong class="strong-star2"><code class="code code1">--latex</code></strong><span data-line="775"></span>. Translates the given touist code to <span data-line="775"></span><span class="math-inline">$\mbox{\LaTeX}$</span><span data-line="775"></span>. The resulting
latex code only require the <span data-line="776"></span><code class="code code1">mathtools</code><span data-line="776"></span> package and is compatible with
Mathjax (JavaScript tool for displaying math in HTML). This command does
not print <span data-line="778"></span><code class="code code1 language-latex lang-latex latex colorized"><span style="color:blue">\begin</span>{<span style="color:navy">document</span>}</code><span data-line="778"></span> nor any latex headers
(<span data-line="779"></span><code class="code code1 language-latex lang-latex latex colorized"><span style="color:blue">\usepackage</span>{}</code><span data-line="779"></span>&#8230;<span data-line="779"></span>). 
</p>
<p class="p indent" data-line="781"><span data-line="781"></span><strong class="strong-star2"><code class="code code1">--show</code></strong><span data-line="781"></span>. This option prints the formula generated by the given
touist file. This is useful for debugging and testing that the
constructs <span data-line="783"></span><code class="code code1">bigand</code><span data-line="783"></span>, <span data-line="783"></span><code class="code code1">bigor</code><span data-line="783"></span>, <span data-line="783"></span><code class="code code1">exact</code><span data-line="783"></span>&#8230;<span data-line="783"></span> are correclty evaluated.
</p>
<p class="p indent" data-line="785"><span data-line="785"></span><strong class="strong-star2"><code class="code code1">--show-hidden</code></strong><span data-line="785"></span>. This is specific to the SAT mode. When displaying
the DIMACS result, also include the hidden propositions that have been
generated during the CNF expansion by the Tseitin transformation<span data-line="787"></span><a href="https://en.wikipedia.org/wiki/Conjunctive_normal_form" data-linkid="tseitlin">tseitlin</a><span data-line="787"></span>.
</p>
<p class="p noindent" data-line="790"><span data-line="790"></span><strong class="strong-star2"><code class="code code1">--linter</code></strong><span data-line="790"></span>. This option disables all outputs except for errors. It
also shortens then evaluation step by bypassing the expansive <span data-line="791"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">bigand</span></code><span data-line="791"></span>,
<span data-line="792"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">exact</span></code><span data-line="792"></span>, <span data-line="792"></span><code class="code code2 language-touist lang-touist touist colorized"><span style="color:blue">powerset</span></code><span data-line="792"></span>&#8230;<span data-line="792"></span> constructs.
</p>
<p class="p indent" data-line="794"><span data-line="794"></span><strong class="strong-star2"><code class="code code1">--detailed-position</code></strong><span data-line="794"></span>. Adds the absolute character position in error
and warning messages with for format <span data-line="795"></span><code class="code code1">line:col:abs_first:abs_last: message</code><span data-line="795"></span>.
</p>
<p class="p indent" data-line="797"><span data-line="797"></span><strong class="strong-star2"><code class="code code1">--debug-syntax</code></strong><span data-line="797"></span>. This is a development option that adds to the error
and warning messages the state number of the LL(1) automaton. Each state
number that may trigger a syntax error should have a corresponding message 
in <span data-line="800"></span><code class="code code1">src/parser.messages</code><span data-line="800"></span>.
</p>
<p class="p indent" data-line="802"><span data-line="802"></span><strong class="strong-star2"><code class="code code1">--debug-cnf</code></strong><span data-line="802"></span>. This is also a development option; in SAT mode, it
prints the successive recursive transformations that produce the CNF formula.
</p><h4 id="sec-usage-for-satisfiability-modulo-theory-smt-mode" class="h3" data-line="805" data-heading-depth="3" style="display:block"><span data-line="805"></span><span class="heading-before"><span class="heading-label">3.2.3</span>.&#8194;</span><span data-line="805"></span>Usage for Satisfiability Modulo Theory (SMT mode)</h4>
<p class="p noindent" data-line="807"><span data-line="807"></span>The language accepted by this mode is described in<span data-line="807"></span>&nbsp;<a href="#sec-smt-formulas" title="2.8.4.&#8194;SMT formulas" class="localref" style="target-element:h3"><span class="heading-label">2.8.4</span></a><span data-line="807"></span>.
The flag <span data-line="808"></span><code class="code code1">--smt</code><span data-line="808"></span> enables the SMT mode.
</p>
<p class="p indent" data-line="810"><span data-line="810"></span>(TODO)
</p>
<div class="bibl" data-line="812;out/reference-manual-bib.bbl.mdk:1" style="bbl-file:out/reference-manual-bib.bbl.mdk"><h2 id="sec-references" class="clearnum h1 heading-references" data-line="812;out/reference-manual-bib.bbl.mdk:2" data-heading-depth="1" style="display:block"><span data-line="812;out/reference-manual-bib.bbl.mdk:2"></span>References</h2>
<div class="bibliography bib-numeric" data-hanging-indent="0" data-cite-style="numeric:&#39;[&#39;,&#39;]&#39;,&#39;, &#39;" data-style="madoko-numeric" data-line="812;out/reference-manual-bib.bbl.mdk:3" style="bibstyle:madoko-numeric">
<div id="ben_slimane_iaf_2015" class="bibitem" data-cite-year="2015a" data-cite-authors="Ben Slimane et al." data-cite-authors-long="Ben Slimane, Comte, Gasquet, Heba, Lezaud, Maris, and Valais" data-cite-label="1" data-line="bibliography.bib:1" style="text-indent:-2rem;margin-left:2rem;searchterm:La%20logique%20facile%20avec%20TouIST%20formalisez%20et%20r%C3%A9solvez%20facilement%20des%20probl%C3%A8mes%20du%20monde%20r%C3%A9el%20Ben%20Slimane%2C%20Comte%2C%20Gasquet%2C%20Heba%2C%20Lezaud%2C%20Maris%2C%20and%20Valais%2C%202015a;bibitem-label:\5C [1\5C ]"><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[1]</span>Khaled Skander Ben Slimane, Alexis Comte, Olivier Gasquet, Abdelwahab Heba, Olivier Lezaud, Frédéric Maris, and Maël Valais. &#8220;La Logique Facile Avec TouIST (formalisez et Résolvez Facilement Des Problèmes Du Monde Réel).&#8221; In <em class="em-low1">Actes Des 9es Journ&#233;es d’Intelligence Artificielle Fondamentale (IAF&#160;2015)</em>. 2015. <a href="http://pfia2015.inria.fr/actes/download.php?conf=IAF&amp;file=Ben_Slimane_IAF_2015.pdf" class="bib-url texturl monospace">http://&#8203;pfia2015.&#8203;inria.&#8203;fr/&#8203;actes/&#8203;download.&#8203;php?&#8203;conf=&#8203;IAF&amp;&#8203;file=&#8203;Ben_&#8203;Slimane_&#8203;IAF_&#8203;2015.&#8203;pdf</a>.&nbsp;<a href="http://www.bing.com/search?q=La%20logique%20facile%20avec%20TouIST%20formalisez%20et%20r%C3%A9solvez%20facilement%20des%20probl%C3%A8mes%20du%20monde%20r%C3%A9el%20Ben%20Slimane%2C%20Comte%2C%20Gasquet%2C%20Heba%2C%20Lezaud%2C%20Maris%2C%20and%20Valais%2C%202015a" class="bibsearch">&#128270;</a></div>
<div id="slimanecghlmv15" class="bibitem" data-cite-year="2015b" data-cite-authors="Ben Slimane et al." data-cite-authors-long="Ben Slimane, Comte, Gasquet, Heba, Lezaud, Maris, and Valais" data-cite-label="2" data-line="bibliography.bib:9" style="text-indent:-2rem;margin-left:2rem;searchterm:Twist%20your%20logic%20with%20TouIST%20Ben%20Slimane%2C%20Comte%2C%20Gasquet%2C%20Heba%2C%20Lezaud%2C%20Maris%2C%20and%20Valais%2C%202015b;bibitem-label:\5C [2\5C ]"><span class="bibitem-before" style="padding-right:0.5em;display: inline-block; width:calc(2rem - 0.5em);display: inline-block; text-align:right;font-size:90%">[2]</span>Khaled Skander Ben Slimane, Alexis Comte, Olivier Gasquet, Abdelwahab Heba, Olivier Lezaud, Frederic Maris, and Mael Valais. &#8220;Twist Your Logic with TouIST.&#8221; <em class="em-low1">CoRR</em> abs/1507.03663. 2015. <a href="http://arxiv.org/abs/1507.03663" class="bib-url texturl monospace">http://&#8203;arxiv.&#8203;org/&#8203;abs/&#8203;1507.&#8203;03663</a>.&nbsp;<a href="http://www.bing.com/search?q=Twist%20your%20logic%20with%20TouIST%20Ben%20Slimane%2C%20Comte%2C%20Gasquet%2C%20Heba%2C%20Lezaud%2C%20Maris%2C%20and%20Valais%2C%202015b" class="bibsearch">&#128270;</a></div></div></div><span data-line=""></span></div>
</body>

</html>
